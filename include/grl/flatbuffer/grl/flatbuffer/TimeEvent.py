# automatically generated by the FlatBuffers compiler, do not modify

# namespace: flatbuffer

import flatbuffers

# /// Note that all of these time entries are
# /// longs with a minimum step of 100ns,
# /// see google cartographer's cartographer::common::time
class TimeEvent(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAsTimeEvent(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TimeEvent()
        x.Init(buf, n + offset)
        return x

    # TimeEvent
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

# /// Identifying string for this time stamped data topic
# /// something like "/opticaltracker/00000000/frame" where
# /// 00000000 is the serial number of the optical tracker.
    # TimeEvent
    def EventName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return bytes()

# /// The time just before a data update request is made
    # TimeEvent
    def LocalRequestTime(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

# /// Identifying string for the clock used to drive the device
# /// something like "/opticaltracker/00000000/clock"
# /// if it is the clock internal to a sensor like an optical tracker
    # TimeEvent
    def DeviceClockId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return bytes()

# /// The time provided by the device specified by device_clock_id
    # TimeEvent
    def DeviceTime(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

# /// Identifying string for the clock used to drive the device
# /// or "/control_computer/clock/steady" if the device has no clock
# /// and the time is the desktop computer
# /// running the steady clock (vs clocks which might change time)
    # TimeEvent
    def LocalClockId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return bytes()

# /// The time at which the data was received
    # TimeEvent
    def LocalReceiveTime(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

# /// The corrected local time which represents when the sensor
# /// data was actually captured.
    # TimeEvent
    def CorrectedLocalTime(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

# /// Estimated duration of the skew between the device clock
# /// and the local time clock
    # TimeEvent
    def ClockSkew(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

# /// The minimum expected delay in transporting the data request
    # TimeEvent
    def MinTransportDelay(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

def TimeEventStart(builder): builder.StartObject(9)
def TimeEventAddEventName(builder, eventName): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(eventName), 0)
def TimeEventAddLocalRequestTime(builder, localRequestTime): builder.PrependInt64Slot(1, localRequestTime, 0)
def TimeEventAddDeviceClockId(builder, deviceClockId): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(deviceClockId), 0)
def TimeEventAddDeviceTime(builder, deviceTime): builder.PrependInt64Slot(3, deviceTime, 0)
def TimeEventAddLocalClockId(builder, localClockId): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(localClockId), 0)
def TimeEventAddLocalReceiveTime(builder, localReceiveTime): builder.PrependInt64Slot(5, localReceiveTime, 0)
def TimeEventAddCorrectedLocalTime(builder, correctedLocalTime): builder.PrependInt64Slot(6, correctedLocalTime, 0)
def TimeEventAddClockSkew(builder, clockSkew): builder.PrependInt64Slot(7, clockSkew, 0)
def TimeEventAddMinTransportDelay(builder, minTransportDelay): builder.PrependInt64Slot(8, minTransportDelay, 0)
def TimeEventEnd(builder): return builder.EndObject()
