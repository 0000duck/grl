// automatically generated by the FlatBuffers compiler, do not modify

package grl.flatbuffer;

import java.nio.*;
import java.lang.*;
import java.util.*;
import com.google.flatbuffers.*;

@SuppressWarnings("unused")
/**
 * Note that all of these time entries are
 * longs with a minimum step of 100ns,
 * see google cartographer's cartographer::common::time
 */
public final class TimeEvent extends Table {
  public static TimeEvent getRootAsTimeEvent(ByteBuffer _bb) { return getRootAsTimeEvent(_bb, new TimeEvent()); }
  public static TimeEvent getRootAsTimeEvent(ByteBuffer _bb, TimeEvent obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { bb_pos = _i; bb = _bb; }
  public TimeEvent __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Identifying string for this time stamped data topic
   * something like "/opticaltracker/00000000/frame" where
   * 00000000 is the serial number of the optical tracker.
   */
  public String eventName() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer eventNameAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer eventNameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * The time just before a data update request is made
   */
  public long localRequestTime() { int o = __offset(6); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * Identifying string for the clock used to drive the device
   * something like "/opticaltracker/00000000/clock"
   * if it is the clock internal to a sensor like an optical tracker
   */
  public String deviceClockId() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer deviceClockIdAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer deviceClockIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * The time provided by the device specified by device_clock_id
   */
  public long deviceTime() { int o = __offset(10); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * Identifying string for the clock used to drive the device
   * or "/control_computer/clock/steady" if the device has no clock
   * and the time is the desktop computer
   * running the steady clock (vs clocks which might change time)
   */
  public String localClockId() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer localClockIdAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer localClockIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * The time at which the data was received
   */
  public long localReceiveTime() { int o = __offset(14); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * The corrected local time which represents when the sensor
   * data was actually captured.
   */
  public long correctedLocalTime() { int o = __offset(16); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * Estimated duration of the skew between the device clock
   * and the local time clock
   */
  public long clockSkew() { int o = __offset(18); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * The minimum expected delay in transporting the data request
   */
  public long minTransportDelay() { int o = __offset(20); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }

  public static int createTimeEvent(FlatBufferBuilder builder,
      int event_nameOffset,
      long local_request_time,
      int device_clock_idOffset,
      long device_time,
      int local_clock_idOffset,
      long local_receive_time,
      long corrected_local_time,
      long clock_skew,
      long min_transport_delay) {
    builder.startObject(9);
    TimeEvent.addMinTransportDelay(builder, min_transport_delay);
    TimeEvent.addClockSkew(builder, clock_skew);
    TimeEvent.addCorrectedLocalTime(builder, corrected_local_time);
    TimeEvent.addLocalReceiveTime(builder, local_receive_time);
    TimeEvent.addDeviceTime(builder, device_time);
    TimeEvent.addLocalRequestTime(builder, local_request_time);
    TimeEvent.addLocalClockId(builder, local_clock_idOffset);
    TimeEvent.addDeviceClockId(builder, device_clock_idOffset);
    TimeEvent.addEventName(builder, event_nameOffset);
    return TimeEvent.endTimeEvent(builder);
  }

  public static void startTimeEvent(FlatBufferBuilder builder) { builder.startObject(9); }
  public static void addEventName(FlatBufferBuilder builder, int eventNameOffset) { builder.addOffset(0, eventNameOffset, 0); }
  public static void addLocalRequestTime(FlatBufferBuilder builder, long localRequestTime) { builder.addLong(1, localRequestTime, 0L); }
  public static void addDeviceClockId(FlatBufferBuilder builder, int deviceClockIdOffset) { builder.addOffset(2, deviceClockIdOffset, 0); }
  public static void addDeviceTime(FlatBufferBuilder builder, long deviceTime) { builder.addLong(3, deviceTime, 0L); }
  public static void addLocalClockId(FlatBufferBuilder builder, int localClockIdOffset) { builder.addOffset(4, localClockIdOffset, 0); }
  public static void addLocalReceiveTime(FlatBufferBuilder builder, long localReceiveTime) { builder.addLong(5, localReceiveTime, 0L); }
  public static void addCorrectedLocalTime(FlatBufferBuilder builder, long correctedLocalTime) { builder.addLong(6, correctedLocalTime, 0L); }
  public static void addClockSkew(FlatBufferBuilder builder, long clockSkew) { builder.addLong(7, clockSkew, 0L); }
  public static void addMinTransportDelay(FlatBufferBuilder builder, long minTransportDelay) { builder.addLong(8, minTransportDelay, 0L); }
  public static int endTimeEvent(FlatBufferBuilder builder) {
    int o = builder.endObject();
    return o;
  }
}

