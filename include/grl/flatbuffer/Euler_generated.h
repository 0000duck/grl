// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EULER_GRL_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_EULER_GRL_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

#include "Geometry_generated.h"

namespace grl {
namespace flatbuffer {

struct EulerXYZd;

struct EulerRotation;

struct EulerPose;

struct EulerTranslationParams;
struct EulerTranslationParamsT;

struct EulerRotationParams;
struct EulerRotationParamsT;

struct EulerPoseParams;
struct EulerPoseParamsT;

enum class EulerOrder : int8_t {
  xyz = 0,
  yzx = 1,
  zxy = 2,
  xzy = 3,
  zyx = 4,
  yxz = 5,
  zxz = 6,
  xyx = 7,
  yzy = 8,
  xzx = 9,
  yxy = 10,
  MIN = xyz,
  MAX = yxy
};

inline const EulerOrder (&EnumValuesEulerOrder())[11] {
  static const EulerOrder values[] = {
    EulerOrder::xyz,
    EulerOrder::yzx,
    EulerOrder::zxy,
    EulerOrder::xzy,
    EulerOrder::zyx,
    EulerOrder::yxz,
    EulerOrder::zxz,
    EulerOrder::xyx,
    EulerOrder::yzy,
    EulerOrder::xzx,
    EulerOrder::yxy
  };
  return values;
}

inline const char * const *EnumNamesEulerOrder() {
  static const char * const names[] = {
    "xyz",
    "yzx",
    "zxy",
    "xzy",
    "zyx",
    "yxz",
    "zxz",
    "xyx",
    "yzy",
    "xzx",
    "yxy",
    nullptr
  };
  return names;
}

inline const char *EnumNameEulerOrder(EulerOrder e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEulerOrder()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) EulerXYZd FLATBUFFERS_FINAL_CLASS {
 private:
  double rx_;
  double ry_;
  double rz_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerXYZd";
  }
  EulerXYZd() {
    memset(this, 0, sizeof(EulerXYZd));
  }
  EulerXYZd(double _rx, double _ry, double _rz)
      : rx_(flatbuffers::EndianScalar(_rx)),
        ry_(flatbuffers::EndianScalar(_ry)),
        rz_(flatbuffers::EndianScalar(_rz)) {
  }
  double rx() const {
    return flatbuffers::EndianScalar(rx_);
  }
  double ry() const {
    return flatbuffers::EndianScalar(ry_);
  }
  double rz() const {
    return flatbuffers::EndianScalar(rz_);
  }
};
FLATBUFFERS_STRUCT_END(EulerXYZd, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) EulerRotation FLATBUFFERS_FINAL_CLASS {
 private:
  double r1_;
  double r2_;
  double r3_;
  int8_t eulerOrder_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerRotation";
  }
  EulerRotation() {
    memset(this, 0, sizeof(EulerRotation));
  }
  EulerRotation(double _r1, double _r2, double _r3, EulerOrder _eulerOrder)
      : r1_(flatbuffers::EndianScalar(_r1)),
        r2_(flatbuffers::EndianScalar(_r2)),
        r3_(flatbuffers::EndianScalar(_r3)),
        eulerOrder_(flatbuffers::EndianScalar(static_cast<int8_t>(_eulerOrder))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  double r1() const {
    return flatbuffers::EndianScalar(r1_);
  }
  double r2() const {
    return flatbuffers::EndianScalar(r2_);
  }
  double r3() const {
    return flatbuffers::EndianScalar(r3_);
  }
  EulerOrder eulerOrder() const {
    return static_cast<EulerOrder>(flatbuffers::EndianScalar(eulerOrder_));
  }
};
FLATBUFFERS_STRUCT_END(EulerRotation, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) EulerPose FLATBUFFERS_FINAL_CLASS {
 private:
  Vector3d position_;
  EulerRotation rotation_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerPose";
  }
  EulerPose() {
    memset(this, 0, sizeof(EulerPose));
  }
  EulerPose(const Vector3d &_position, const EulerRotation &_rotation)
      : position_(_position),
        rotation_(_rotation) {
  }
  const Vector3d &position() const {
    return position_;
  }
  const EulerRotation &rotation() const {
    return rotation_;
  }
};
FLATBUFFERS_STRUCT_END(EulerPose, 56);

struct EulerTranslationParamsT : public flatbuffers::NativeTable {
  typedef EulerTranslationParams TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerTranslationParamsT";
  }
  double x;
  double y;
  double z;
  EulerTranslationParamsT()
      : x(0.0),
        y(0.0),
        z(0.0) {
  }
};

struct EulerTranslationParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EulerTranslationParamsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerTranslationParams";
  }
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  EulerTranslationParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EulerTranslationParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EulerTranslationParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EulerTranslationParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EulerTranslationParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(EulerTranslationParams::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(EulerTranslationParams::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(EulerTranslationParams::VT_Z, z, 0.0);
  }
  explicit EulerTranslationParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EulerTranslationParamsBuilder &operator=(const EulerTranslationParamsBuilder &);
  flatbuffers::Offset<EulerTranslationParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EulerTranslationParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<EulerTranslationParams> CreateEulerTranslationParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  EulerTranslationParamsBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

flatbuffers::Offset<EulerTranslationParams> CreateEulerTranslationParams(flatbuffers::FlatBufferBuilder &_fbb, const EulerTranslationParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EulerRotationParamsT : public flatbuffers::NativeTable {
  typedef EulerRotationParams TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerRotationParamsT";
  }
  double r1;
  double r2;
  double r3;
  EulerOrder eulerOrder;
  EulerRotationParamsT()
      : r1(0.0),
        r2(0.0),
        r3(0.0),
        eulerOrder(EulerOrder::xyz) {
  }
};

struct EulerRotationParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EulerRotationParamsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerRotationParams";
  }
  enum {
    VT_R1 = 4,
    VT_R2 = 6,
    VT_R3 = 8,
    VT_EULERORDER = 10
  };
  double r1() const {
    return GetField<double>(VT_R1, 0.0);
  }
  double r2() const {
    return GetField<double>(VT_R2, 0.0);
  }
  double r3() const {
    return GetField<double>(VT_R3, 0.0);
  }
  EulerOrder eulerOrder() const {
    return static_cast<EulerOrder>(GetField<int8_t>(VT_EULERORDER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_R1) &&
           VerifyField<double>(verifier, VT_R2) &&
           VerifyField<double>(verifier, VT_R3) &&
           VerifyField<int8_t>(verifier, VT_EULERORDER) &&
           verifier.EndTable();
  }
  EulerRotationParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EulerRotationParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EulerRotationParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EulerRotationParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EulerRotationParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_r1(double r1) {
    fbb_.AddElement<double>(EulerRotationParams::VT_R1, r1, 0.0);
  }
  void add_r2(double r2) {
    fbb_.AddElement<double>(EulerRotationParams::VT_R2, r2, 0.0);
  }
  void add_r3(double r3) {
    fbb_.AddElement<double>(EulerRotationParams::VT_R3, r3, 0.0);
  }
  void add_eulerOrder(EulerOrder eulerOrder) {
    fbb_.AddElement<int8_t>(EulerRotationParams::VT_EULERORDER, static_cast<int8_t>(eulerOrder), 0);
  }
  explicit EulerRotationParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EulerRotationParamsBuilder &operator=(const EulerRotationParamsBuilder &);
  flatbuffers::Offset<EulerRotationParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EulerRotationParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<EulerRotationParams> CreateEulerRotationParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    double r1 = 0.0,
    double r2 = 0.0,
    double r3 = 0.0,
    EulerOrder eulerOrder = EulerOrder::xyz) {
  EulerRotationParamsBuilder builder_(_fbb);
  builder_.add_r3(r3);
  builder_.add_r2(r2);
  builder_.add_r1(r1);
  builder_.add_eulerOrder(eulerOrder);
  return builder_.Finish();
}

flatbuffers::Offset<EulerRotationParams> CreateEulerRotationParams(flatbuffers::FlatBufferBuilder &_fbb, const EulerRotationParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EulerPoseParamsT : public flatbuffers::NativeTable {
  typedef EulerPoseParams TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerPoseParamsT";
  }
  std::unique_ptr<Vector3d> position;
  std::unique_ptr<EulerRotation> rotation;
  EulerPoseParamsT() {
  }
};

struct EulerPoseParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EulerPoseParamsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.EulerPoseParams";
  }
  enum {
    VT_POSITION = 4,
    VT_ROTATION = 6
  };
  const Vector3d *position() const {
    return GetStruct<const Vector3d *>(VT_POSITION);
  }
  const EulerRotation *rotation() const {
    return GetStruct<const EulerRotation *>(VT_ROTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3d>(verifier, VT_POSITION) &&
           VerifyField<EulerRotation>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  EulerPoseParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EulerPoseParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EulerPoseParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EulerPoseParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EulerPoseParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const Vector3d *position) {
    fbb_.AddStruct(EulerPoseParams::VT_POSITION, position);
  }
  void add_rotation(const EulerRotation *rotation) {
    fbb_.AddStruct(EulerPoseParams::VT_ROTATION, rotation);
  }
  explicit EulerPoseParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EulerPoseParamsBuilder &operator=(const EulerPoseParamsBuilder &);
  flatbuffers::Offset<EulerPoseParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EulerPoseParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<EulerPoseParams> CreateEulerPoseParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector3d *position = 0,
    const EulerRotation *rotation = 0) {
  EulerPoseParamsBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  return builder_.Finish();
}

flatbuffers::Offset<EulerPoseParams> CreateEulerPoseParams(flatbuffers::FlatBufferBuilder &_fbb, const EulerPoseParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EulerTranslationParamsT *EulerTranslationParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EulerTranslationParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EulerTranslationParams::UnPackTo(EulerTranslationParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; };
  { auto _e = y(); _o->y = _e; };
  { auto _e = z(); _o->z = _e; };
}

inline flatbuffers::Offset<EulerTranslationParams> EulerTranslationParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EulerTranslationParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEulerTranslationParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EulerTranslationParams> CreateEulerTranslationParams(flatbuffers::FlatBufferBuilder &_fbb, const EulerTranslationParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EulerTranslationParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return grl::flatbuffer::CreateEulerTranslationParams(
      _fbb,
      _x,
      _y,
      _z);
}

inline EulerRotationParamsT *EulerRotationParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EulerRotationParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EulerRotationParams::UnPackTo(EulerRotationParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = r1(); _o->r1 = _e; };
  { auto _e = r2(); _o->r2 = _e; };
  { auto _e = r3(); _o->r3 = _e; };
  { auto _e = eulerOrder(); _o->eulerOrder = _e; };
}

inline flatbuffers::Offset<EulerRotationParams> EulerRotationParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EulerRotationParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEulerRotationParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EulerRotationParams> CreateEulerRotationParams(flatbuffers::FlatBufferBuilder &_fbb, const EulerRotationParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EulerRotationParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _r1 = _o->r1;
  auto _r2 = _o->r2;
  auto _r3 = _o->r3;
  auto _eulerOrder = _o->eulerOrder;
  return grl::flatbuffer::CreateEulerRotationParams(
      _fbb,
      _r1,
      _r2,
      _r3,
      _eulerOrder);
}

inline EulerPoseParamsT *EulerPoseParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EulerPoseParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EulerPoseParams::UnPackTo(EulerPoseParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<Vector3d>(new Vector3d(*_e)); };
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<EulerRotation>(new EulerRotation(*_e)); };
}

inline flatbuffers::Offset<EulerPoseParams> EulerPoseParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EulerPoseParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEulerPoseParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EulerPoseParams> CreateEulerPoseParams(flatbuffers::FlatBufferBuilder &_fbb, const EulerPoseParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EulerPoseParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  return grl::flatbuffer::CreateEulerPoseParams(
      _fbb,
      _position,
      _rotation);
}

}  // namespace flatbuffer
}  // namespace grl

#endif  // FLATBUFFERS_GENERATED_EULER_GRL_FLATBUFFER_H_
