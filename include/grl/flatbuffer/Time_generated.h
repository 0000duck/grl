// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TIME_GRL_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_TIME_GRL_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace grl {
namespace flatbuffer {

struct Time;

struct TimeEvent;
struct TimeEventT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Time FLATBUFFERS_FINAL_CLASS {
 private:
  double sec_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.Time";
  }
  Time() {
    memset(this, 0, sizeof(Time));
  }
  Time(double _sec)
      : sec_(flatbuffers::EndianScalar(_sec)) {
  }
  double sec() const {
    return flatbuffers::EndianScalar(sec_);
  }
};
FLATBUFFERS_STRUCT_END(Time, 8);

struct TimeEventT : public flatbuffers::NativeTable {
  typedef TimeEvent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.TimeEventT";
  }
  std::string event_name;
  int64_t local_request_time;
  std::string device_clock_id;
  int64_t device_time;
  std::string local_clock_id;
  int64_t local_receive_time;
  int64_t corrected_local_time;
  int64_t clock_skew;
  int64_t min_transport_delay;
  TimeEventT()
      : local_request_time(0),
        device_time(0),
        local_receive_time(0),
        corrected_local_time(0),
        clock_skew(0),
        min_transport_delay(0) {
  }
};

/// Note that all of these time entries are
/// longs with a minimum step of 100ns,
/// see google cartographer's cartographer::common::time
struct TimeEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeEventT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.TimeEvent";
  }
  enum {
    VT_EVENT_NAME = 4,
    VT_LOCAL_REQUEST_TIME = 6,
    VT_DEVICE_CLOCK_ID = 8,
    VT_DEVICE_TIME = 10,
    VT_LOCAL_CLOCK_ID = 12,
    VT_LOCAL_RECEIVE_TIME = 14,
    VT_CORRECTED_LOCAL_TIME = 16,
    VT_CLOCK_SKEW = 18,
    VT_MIN_TRANSPORT_DELAY = 20
  };
  /// Identifying string for this time stamped data topic
  /// something like "/opticaltracker/00000000/frame" where
  /// 00000000 is the serial number of the optical tracker.
  const flatbuffers::String *event_name() const {
    return GetPointer<const flatbuffers::String *>(VT_EVENT_NAME);
  }
  /// The time just before a data update request is made
  int64_t local_request_time() const {
    return GetField<int64_t>(VT_LOCAL_REQUEST_TIME, 0);
  }
  /// Identifying string for the clock used to drive the device
  /// something like "/opticaltracker/00000000/clock"
  /// if it is the clock internal to a sensor like an optical tracker
  const flatbuffers::String *device_clock_id() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_CLOCK_ID);
  }
  /// The time provided by the device specified by device_clock_id
  int64_t device_time() const {
    return GetField<int64_t>(VT_DEVICE_TIME, 0);
  }
  /// Identifying string for the clock used to drive the device
  /// or "/control_computer/clock/steady" if the device has no clock
  /// and the time is the desktop computer
  /// running the steady clock (vs clocks which might change time)
  const flatbuffers::String *local_clock_id() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCAL_CLOCK_ID);
  }
  /// The time at which the data was received
  int64_t local_receive_time() const {
    return GetField<int64_t>(VT_LOCAL_RECEIVE_TIME, 0);
  }
  /// The corrected local time which represents when the sensor
  /// data was actually captured.
  int64_t corrected_local_time() const {
    return GetField<int64_t>(VT_CORRECTED_LOCAL_TIME, 0);
  }
  /// Estimated duration of the skew between the device clock
  /// and the local time clock
  int64_t clock_skew() const {
    return GetField<int64_t>(VT_CLOCK_SKEW, 0);
  }
  /// The minimum expected delay in transporting the data request
  int64_t min_transport_delay() const {
    return GetField<int64_t>(VT_MIN_TRANSPORT_DELAY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_NAME) &&
           verifier.Verify(event_name()) &&
           VerifyField<int64_t>(verifier, VT_LOCAL_REQUEST_TIME) &&
           VerifyOffset(verifier, VT_DEVICE_CLOCK_ID) &&
           verifier.Verify(device_clock_id()) &&
           VerifyField<int64_t>(verifier, VT_DEVICE_TIME) &&
           VerifyOffset(verifier, VT_LOCAL_CLOCK_ID) &&
           verifier.Verify(local_clock_id()) &&
           VerifyField<int64_t>(verifier, VT_LOCAL_RECEIVE_TIME) &&
           VerifyField<int64_t>(verifier, VT_CORRECTED_LOCAL_TIME) &&
           VerifyField<int64_t>(verifier, VT_CLOCK_SKEW) &&
           VerifyField<int64_t>(verifier, VT_MIN_TRANSPORT_DELAY) &&
           verifier.EndTable();
  }
  TimeEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimeEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_name(flatbuffers::Offset<flatbuffers::String> event_name) {
    fbb_.AddOffset(TimeEvent::VT_EVENT_NAME, event_name);
  }
  void add_local_request_time(int64_t local_request_time) {
    fbb_.AddElement<int64_t>(TimeEvent::VT_LOCAL_REQUEST_TIME, local_request_time, 0);
  }
  void add_device_clock_id(flatbuffers::Offset<flatbuffers::String> device_clock_id) {
    fbb_.AddOffset(TimeEvent::VT_DEVICE_CLOCK_ID, device_clock_id);
  }
  void add_device_time(int64_t device_time) {
    fbb_.AddElement<int64_t>(TimeEvent::VT_DEVICE_TIME, device_time, 0);
  }
  void add_local_clock_id(flatbuffers::Offset<flatbuffers::String> local_clock_id) {
    fbb_.AddOffset(TimeEvent::VT_LOCAL_CLOCK_ID, local_clock_id);
  }
  void add_local_receive_time(int64_t local_receive_time) {
    fbb_.AddElement<int64_t>(TimeEvent::VT_LOCAL_RECEIVE_TIME, local_receive_time, 0);
  }
  void add_corrected_local_time(int64_t corrected_local_time) {
    fbb_.AddElement<int64_t>(TimeEvent::VT_CORRECTED_LOCAL_TIME, corrected_local_time, 0);
  }
  void add_clock_skew(int64_t clock_skew) {
    fbb_.AddElement<int64_t>(TimeEvent::VT_CLOCK_SKEW, clock_skew, 0);
  }
  void add_min_transport_delay(int64_t min_transport_delay) {
    fbb_.AddElement<int64_t>(TimeEvent::VT_MIN_TRANSPORT_DELAY, min_transport_delay, 0);
  }
  explicit TimeEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeEventBuilder &operator=(const TimeEventBuilder &);
  flatbuffers::Offset<TimeEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeEvent> CreateTimeEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> event_name = 0,
    int64_t local_request_time = 0,
    flatbuffers::Offset<flatbuffers::String> device_clock_id = 0,
    int64_t device_time = 0,
    flatbuffers::Offset<flatbuffers::String> local_clock_id = 0,
    int64_t local_receive_time = 0,
    int64_t corrected_local_time = 0,
    int64_t clock_skew = 0,
    int64_t min_transport_delay = 0) {
  TimeEventBuilder builder_(_fbb);
  builder_.add_min_transport_delay(min_transport_delay);
  builder_.add_clock_skew(clock_skew);
  builder_.add_corrected_local_time(corrected_local_time);
  builder_.add_local_receive_time(local_receive_time);
  builder_.add_device_time(device_time);
  builder_.add_local_request_time(local_request_time);
  builder_.add_local_clock_id(local_clock_id);
  builder_.add_device_clock_id(device_clock_id);
  builder_.add_event_name(event_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TimeEvent> CreateTimeEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *event_name = nullptr,
    int64_t local_request_time = 0,
    const char *device_clock_id = nullptr,
    int64_t device_time = 0,
    const char *local_clock_id = nullptr,
    int64_t local_receive_time = 0,
    int64_t corrected_local_time = 0,
    int64_t clock_skew = 0,
    int64_t min_transport_delay = 0) {
  return grl::flatbuffer::CreateTimeEvent(
      _fbb,
      event_name ? _fbb.CreateString(event_name) : 0,
      local_request_time,
      device_clock_id ? _fbb.CreateString(device_clock_id) : 0,
      device_time,
      local_clock_id ? _fbb.CreateString(local_clock_id) : 0,
      local_receive_time,
      corrected_local_time,
      clock_skew,
      min_transport_delay);
}

flatbuffers::Offset<TimeEvent> CreateTimeEvent(flatbuffers::FlatBufferBuilder &_fbb, const TimeEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TimeEventT *TimeEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TimeEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TimeEvent::UnPackTo(TimeEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_name(); if (_e) _o->event_name = _e->str(); };
  { auto _e = local_request_time(); _o->local_request_time = _e; };
  { auto _e = device_clock_id(); if (_e) _o->device_clock_id = _e->str(); };
  { auto _e = device_time(); _o->device_time = _e; };
  { auto _e = local_clock_id(); if (_e) _o->local_clock_id = _e->str(); };
  { auto _e = local_receive_time(); _o->local_receive_time = _e; };
  { auto _e = corrected_local_time(); _o->corrected_local_time = _e; };
  { auto _e = clock_skew(); _o->clock_skew = _e; };
  { auto _e = min_transport_delay(); _o->min_transport_delay = _e; };
}

inline flatbuffers::Offset<TimeEvent> TimeEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimeEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimeEvent> CreateTimeEvent(flatbuffers::FlatBufferBuilder &_fbb, const TimeEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimeEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_name = _o->event_name.empty() ? 0 : _fbb.CreateString(_o->event_name);
  auto _local_request_time = _o->local_request_time;
  auto _device_clock_id = _o->device_clock_id.empty() ? 0 : _fbb.CreateString(_o->device_clock_id);
  auto _device_time = _o->device_time;
  auto _local_clock_id = _o->local_clock_id.empty() ? 0 : _fbb.CreateString(_o->local_clock_id);
  auto _local_receive_time = _o->local_receive_time;
  auto _corrected_local_time = _o->corrected_local_time;
  auto _clock_skew = _o->clock_skew;
  auto _min_transport_delay = _o->min_transport_delay;
  return grl::flatbuffer::CreateTimeEvent(
      _fbb,
      _event_name,
      _local_request_time,
      _device_clock_id,
      _device_time,
      _local_clock_id,
      _local_receive_time,
      _corrected_local_time,
      _clock_skew,
      _min_transport_delay);
}

}  // namespace flatbuffer
}  // namespace grl

#endif  // FLATBUFFERS_GENERATED_TIME_GRL_FLATBUFFER_H_
