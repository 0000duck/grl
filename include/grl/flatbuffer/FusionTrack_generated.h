// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FUSIONTRACK_GRL_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_FUSIONTRACK_GRL_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

#include "Geometry_generated.h"
#include "Time_generated.h"

namespace grl {
namespace flatbuffer {

struct ftkGeometry;
struct ftkGeometryT;

struct ftkMarker;
struct ftkMarkerT;

struct ftk3DFiducial;
struct ftk3DFiducialT;

struct ftkRegionOfInterest;
struct ftkRegionOfInterestT;

struct FusionTrackFrame;
struct FusionTrackFrameT;

struct FusionTrackParameters;
struct FusionTrackParametersT;

struct FusionTrackMessage;
struct FusionTrackMessageT;

enum class ftkQueryStatus : int32_t {
  QS_WAR_SKIPPED = -1,
  QS_OK = 0,
  QS_ERR_OVERFLOW = 1,
  QS_ERR_INVALID_RESERVED_SIZE = 2,
  QS_REPROCESS = 10,
  MIN = QS_WAR_SKIPPED,
  MAX = QS_REPROCESS
};

inline const ftkQueryStatus (&EnumValuesftkQueryStatus())[5] {
  static const ftkQueryStatus values[] = {
    ftkQueryStatus::QS_WAR_SKIPPED,
    ftkQueryStatus::QS_OK,
    ftkQueryStatus::QS_ERR_OVERFLOW,
    ftkQueryStatus::QS_ERR_INVALID_RESERVED_SIZE,
    ftkQueryStatus::QS_REPROCESS
  };
  return values;
}

inline const char * const *EnumNamesftkQueryStatus() {
  static const char * const names[] = {
    "QS_WAR_SKIPPED",
    "QS_OK",
    "QS_ERR_OVERFLOW",
    "QS_ERR_INVALID_RESERVED_SIZE",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "QS_REPROCESS",
    nullptr
  };
  return names;
}

inline const char *EnumNameftkQueryStatus(ftkQueryStatus e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(ftkQueryStatus::QS_WAR_SKIPPED);
  return EnumNamesftkQueryStatus()[index];
}

enum class ftkDeviceType : int32_t {
  DEV_SIMULATOR = 0,
  DEV_INFINITRACK = 1,
  DEV_FUSIONTRACK_500 = 2,
  DEV_FUSIONTRACK_250 = 3,
  DEV_UNKNOWN_DEVICE = 127,
  MIN = DEV_SIMULATOR,
  MAX = DEV_UNKNOWN_DEVICE
};

inline const ftkDeviceType (&EnumValuesftkDeviceType())[5] {
  static const ftkDeviceType values[] = {
    ftkDeviceType::DEV_SIMULATOR,
    ftkDeviceType::DEV_INFINITRACK,
    ftkDeviceType::DEV_FUSIONTRACK_500,
    ftkDeviceType::DEV_FUSIONTRACK_250,
    ftkDeviceType::DEV_UNKNOWN_DEVICE
  };
  return values;
}

struct ftkGeometryT : public flatbuffers::NativeTable {
  typedef ftkGeometry TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftkGeometryT";
  }
  std::string name;
  uint32_t geometryID;
  uint32_t version;
  std::vector<Vector3d> positions;
  ftkGeometryT()
      : geometryID(0),
        version(0) {
  }
};

struct ftkGeometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ftkGeometryT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftkGeometry";
  }
  enum {
    VT_NAME = 4,
    VT_GEOMETRYID = 6,
    VT_VERSION = 8,
    VT_POSITIONS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t geometryID() const {
    return GetField<uint32_t>(VT_GEOMETRYID, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<const Vector3d *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const Vector3d *> *>(VT_POSITIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint32_t>(verifier, VT_GEOMETRYID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.Verify(positions()) &&
           verifier.EndTable();
  }
  ftkGeometryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ftkGeometryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ftkGeometry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftkGeometryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ftkGeometryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ftkGeometry::VT_NAME, name);
  }
  void add_geometryID(uint32_t geometryID) {
    fbb_.AddElement<uint32_t>(ftkGeometry::VT_GEOMETRYID, geometryID, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ftkGeometry::VT_VERSION, version, 0);
  }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const Vector3d *>> positions) {
    fbb_.AddOffset(ftkGeometry::VT_POSITIONS, positions);
  }
  explicit ftkGeometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ftkGeometryBuilder &operator=(const ftkGeometryBuilder &);
  flatbuffers::Offset<ftkGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ftkGeometry>(end);
    return o;
  }
};

inline flatbuffers::Offset<ftkGeometry> CreateftkGeometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t geometryID = 0,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vector3d *>> positions = 0) {
  ftkGeometryBuilder builder_(_fbb);
  builder_.add_positions(positions);
  builder_.add_version(version);
  builder_.add_geometryID(geometryID);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ftkGeometry> CreateftkGeometryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t geometryID = 0,
    uint32_t version = 0,
    const std::vector<Vector3d> *positions = nullptr) {
  return grl::flatbuffer::CreateftkGeometry(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      geometryID,
      version,
      positions ? _fbb.CreateVectorOfStructs<Vector3d>(*positions) : 0);
}

flatbuffers::Offset<ftkGeometry> CreateftkGeometry(flatbuffers::FlatBufferBuilder &_fbb, const ftkGeometryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ftkMarkerT : public flatbuffers::NativeTable {
  typedef ftkMarker TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftkMarkerT";
  }
  std::string name;
  uint32_t ID;
  uint32_t geometryID;
  std::vector<uint32_t> geometryPresenceMask;
  std::unique_ptr<Pose> transform;
  ftkMarkerT()
      : ID(0),
        geometryID(0) {
  }
};

struct ftkMarker FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ftkMarkerT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftkMarker";
  }
  enum {
    VT_NAME = 4,
    VT_ID = 6,
    VT_GEOMETRYID = 8,
    VT_GEOMETRYPRESENCEMASK = 10,
    VT_TRANSFORM = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t ID() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t geometryID() const {
    return GetField<uint32_t>(VT_GEOMETRYID, 0);
  }
  const flatbuffers::Vector<uint32_t> *geometryPresenceMask() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_GEOMETRYPRESENCEMASK);
  }
  const Pose *transform() const {
    return GetStruct<const Pose *>(VT_TRANSFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_GEOMETRYID) &&
           VerifyOffset(verifier, VT_GEOMETRYPRESENCEMASK) &&
           verifier.Verify(geometryPresenceMask()) &&
           VerifyField<Pose>(verifier, VT_TRANSFORM) &&
           verifier.EndTable();
  }
  ftkMarkerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ftkMarkerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ftkMarker> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftkMarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ftkMarkerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ftkMarker::VT_NAME, name);
  }
  void add_ID(uint32_t ID) {
    fbb_.AddElement<uint32_t>(ftkMarker::VT_ID, ID, 0);
  }
  void add_geometryID(uint32_t geometryID) {
    fbb_.AddElement<uint32_t>(ftkMarker::VT_GEOMETRYID, geometryID, 0);
  }
  void add_geometryPresenceMask(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> geometryPresenceMask) {
    fbb_.AddOffset(ftkMarker::VT_GEOMETRYPRESENCEMASK, geometryPresenceMask);
  }
  void add_transform(const Pose *transform) {
    fbb_.AddStruct(ftkMarker::VT_TRANSFORM, transform);
  }
  explicit ftkMarkerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ftkMarkerBuilder &operator=(const ftkMarkerBuilder &);
  flatbuffers::Offset<ftkMarker> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ftkMarker>(end);
    return o;
  }
};

inline flatbuffers::Offset<ftkMarker> CreateftkMarker(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t ID = 0,
    uint32_t geometryID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> geometryPresenceMask = 0,
    const Pose *transform = 0) {
  ftkMarkerBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_geometryPresenceMask(geometryPresenceMask);
  builder_.add_geometryID(geometryID);
  builder_.add_ID(ID);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ftkMarker> CreateftkMarkerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t ID = 0,
    uint32_t geometryID = 0,
    const std::vector<uint32_t> *geometryPresenceMask = nullptr,
    const Pose *transform = 0) {
  return grl::flatbuffer::CreateftkMarker(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      ID,
      geometryID,
      geometryPresenceMask ? _fbb.CreateVector<uint32_t>(*geometryPresenceMask) : 0,
      transform);
}

flatbuffers::Offset<ftkMarker> CreateftkMarker(flatbuffers::FlatBufferBuilder &_fbb, const ftkMarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ftk3DFiducialT : public flatbuffers::NativeTable {
  typedef ftk3DFiducial TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftk3DFiducialT";
  }
  uint32_t markerID;
  uint32_t leftIndex;
  uint32_t rightIndex;
  std::unique_ptr<Vector3d> position;
  double epipolarErrorPixels;
  double triangulationError;
  double probability;
  ftk3DFiducialT()
      : markerID(0),
        leftIndex(0),
        rightIndex(0),
        epipolarErrorPixels(0.0),
        triangulationError(0.0),
        probability(0.0) {
  }
};

struct ftk3DFiducial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ftk3DFiducialT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftk3DFiducial";
  }
  enum {
    VT_MARKERID = 4,
    VT_LEFTINDEX = 6,
    VT_RIGHTINDEX = 8,
    VT_POSITION = 10,
    VT_EPIPOLARERRORPIXELS = 12,
    VT_TRIANGULATIONERROR = 14,
    VT_PROBABILITY = 16
  };
  uint32_t markerID() const {
    return GetField<uint32_t>(VT_MARKERID, 0);
  }
  uint32_t leftIndex() const {
    return GetField<uint32_t>(VT_LEFTINDEX, 0);
  }
  uint32_t rightIndex() const {
    return GetField<uint32_t>(VT_RIGHTINDEX, 0);
  }
  const Vector3d *position() const {
    return GetStruct<const Vector3d *>(VT_POSITION);
  }
  double epipolarErrorPixels() const {
    return GetField<double>(VT_EPIPOLARERRORPIXELS, 0.0);
  }
  double triangulationError() const {
    return GetField<double>(VT_TRIANGULATIONERROR, 0.0);
  }
  double probability() const {
    return GetField<double>(VT_PROBABILITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MARKERID) &&
           VerifyField<uint32_t>(verifier, VT_LEFTINDEX) &&
           VerifyField<uint32_t>(verifier, VT_RIGHTINDEX) &&
           VerifyField<Vector3d>(verifier, VT_POSITION) &&
           VerifyField<double>(verifier, VT_EPIPOLARERRORPIXELS) &&
           VerifyField<double>(verifier, VT_TRIANGULATIONERROR) &&
           VerifyField<double>(verifier, VT_PROBABILITY) &&
           verifier.EndTable();
  }
  ftk3DFiducialT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ftk3DFiducialT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ftk3DFiducial> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftk3DFiducialT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ftk3DFiducialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_markerID(uint32_t markerID) {
    fbb_.AddElement<uint32_t>(ftk3DFiducial::VT_MARKERID, markerID, 0);
  }
  void add_leftIndex(uint32_t leftIndex) {
    fbb_.AddElement<uint32_t>(ftk3DFiducial::VT_LEFTINDEX, leftIndex, 0);
  }
  void add_rightIndex(uint32_t rightIndex) {
    fbb_.AddElement<uint32_t>(ftk3DFiducial::VT_RIGHTINDEX, rightIndex, 0);
  }
  void add_position(const Vector3d *position) {
    fbb_.AddStruct(ftk3DFiducial::VT_POSITION, position);
  }
  void add_epipolarErrorPixels(double epipolarErrorPixels) {
    fbb_.AddElement<double>(ftk3DFiducial::VT_EPIPOLARERRORPIXELS, epipolarErrorPixels, 0.0);
  }
  void add_triangulationError(double triangulationError) {
    fbb_.AddElement<double>(ftk3DFiducial::VT_TRIANGULATIONERROR, triangulationError, 0.0);
  }
  void add_probability(double probability) {
    fbb_.AddElement<double>(ftk3DFiducial::VT_PROBABILITY, probability, 0.0);
  }
  explicit ftk3DFiducialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ftk3DFiducialBuilder &operator=(const ftk3DFiducialBuilder &);
  flatbuffers::Offset<ftk3DFiducial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ftk3DFiducial>(end);
    return o;
  }
};

inline flatbuffers::Offset<ftk3DFiducial> Createftk3DFiducial(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t markerID = 0,
    uint32_t leftIndex = 0,
    uint32_t rightIndex = 0,
    const Vector3d *position = 0,
    double epipolarErrorPixels = 0.0,
    double triangulationError = 0.0,
    double probability = 0.0) {
  ftk3DFiducialBuilder builder_(_fbb);
  builder_.add_probability(probability);
  builder_.add_triangulationError(triangulationError);
  builder_.add_epipolarErrorPixels(epipolarErrorPixels);
  builder_.add_position(position);
  builder_.add_rightIndex(rightIndex);
  builder_.add_leftIndex(leftIndex);
  builder_.add_markerID(markerID);
  return builder_.Finish();
}

flatbuffers::Offset<ftk3DFiducial> Createftk3DFiducial(flatbuffers::FlatBufferBuilder &_fbb, const ftk3DFiducialT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ftkRegionOfInterestT : public flatbuffers::NativeTable {
  typedef ftkRegionOfInterest TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftkRegionOfInterestT";
  }
  double centerXPixels;
  double centerYPixels;
  uint32_t RightEdge;
  uint32_t BottomEdge;
  uint32_t LeftEdge;
  uint32_t TopEdge;
  uint32_t pixelsCount;
  double probability;
  ftkRegionOfInterestT()
      : centerXPixels(0.0),
        centerYPixels(0.0),
        RightEdge(0),
        BottomEdge(0),
        LeftEdge(0),
        TopEdge(0),
        pixelsCount(0),
        probability(0.0) {
  }
};

struct ftkRegionOfInterest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ftkRegionOfInterestT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ftkRegionOfInterest";
  }
  enum {
    VT_CENTERXPIXELS = 4,
    VT_CENTERYPIXELS = 6,
    VT_RIGHTEDGE = 8,
    VT_BOTTOMEDGE = 10,
    VT_LEFTEDGE = 12,
    VT_TOPEDGE = 14,
    VT_PIXELSCOUNT = 16,
    VT_PROBABILITY = 18
  };
  double centerXPixels() const {
    return GetField<double>(VT_CENTERXPIXELS, 0.0);
  }
  double centerYPixels() const {
    return GetField<double>(VT_CENTERYPIXELS, 0.0);
  }
  uint32_t RightEdge() const {
    return GetField<uint32_t>(VT_RIGHTEDGE, 0);
  }
  uint32_t BottomEdge() const {
    return GetField<uint32_t>(VT_BOTTOMEDGE, 0);
  }
  uint32_t LeftEdge() const {
    return GetField<uint32_t>(VT_LEFTEDGE, 0);
  }
  uint32_t TopEdge() const {
    return GetField<uint32_t>(VT_TOPEDGE, 0);
  }
  uint32_t pixelsCount() const {
    return GetField<uint32_t>(VT_PIXELSCOUNT, 0);
  }
  double probability() const {
    return GetField<double>(VT_PROBABILITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_CENTERXPIXELS) &&
           VerifyField<double>(verifier, VT_CENTERYPIXELS) &&
           VerifyField<uint32_t>(verifier, VT_RIGHTEDGE) &&
           VerifyField<uint32_t>(verifier, VT_BOTTOMEDGE) &&
           VerifyField<uint32_t>(verifier, VT_LEFTEDGE) &&
           VerifyField<uint32_t>(verifier, VT_TOPEDGE) &&
           VerifyField<uint32_t>(verifier, VT_PIXELSCOUNT) &&
           VerifyField<double>(verifier, VT_PROBABILITY) &&
           verifier.EndTable();
  }
  ftkRegionOfInterestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ftkRegionOfInterestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ftkRegionOfInterest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftkRegionOfInterestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ftkRegionOfInterestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_centerXPixels(double centerXPixels) {
    fbb_.AddElement<double>(ftkRegionOfInterest::VT_CENTERXPIXELS, centerXPixels, 0.0);
  }
  void add_centerYPixels(double centerYPixels) {
    fbb_.AddElement<double>(ftkRegionOfInterest::VT_CENTERYPIXELS, centerYPixels, 0.0);
  }
  void add_RightEdge(uint32_t RightEdge) {
    fbb_.AddElement<uint32_t>(ftkRegionOfInterest::VT_RIGHTEDGE, RightEdge, 0);
  }
  void add_BottomEdge(uint32_t BottomEdge) {
    fbb_.AddElement<uint32_t>(ftkRegionOfInterest::VT_BOTTOMEDGE, BottomEdge, 0);
  }
  void add_LeftEdge(uint32_t LeftEdge) {
    fbb_.AddElement<uint32_t>(ftkRegionOfInterest::VT_LEFTEDGE, LeftEdge, 0);
  }
  void add_TopEdge(uint32_t TopEdge) {
    fbb_.AddElement<uint32_t>(ftkRegionOfInterest::VT_TOPEDGE, TopEdge, 0);
  }
  void add_pixelsCount(uint32_t pixelsCount) {
    fbb_.AddElement<uint32_t>(ftkRegionOfInterest::VT_PIXELSCOUNT, pixelsCount, 0);
  }
  void add_probability(double probability) {
    fbb_.AddElement<double>(ftkRegionOfInterest::VT_PROBABILITY, probability, 0.0);
  }
  explicit ftkRegionOfInterestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ftkRegionOfInterestBuilder &operator=(const ftkRegionOfInterestBuilder &);
  flatbuffers::Offset<ftkRegionOfInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ftkRegionOfInterest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ftkRegionOfInterest> CreateftkRegionOfInterest(
    flatbuffers::FlatBufferBuilder &_fbb,
    double centerXPixels = 0.0,
    double centerYPixels = 0.0,
    uint32_t RightEdge = 0,
    uint32_t BottomEdge = 0,
    uint32_t LeftEdge = 0,
    uint32_t TopEdge = 0,
    uint32_t pixelsCount = 0,
    double probability = 0.0) {
  ftkRegionOfInterestBuilder builder_(_fbb);
  builder_.add_probability(probability);
  builder_.add_centerYPixels(centerYPixels);
  builder_.add_centerXPixels(centerXPixels);
  builder_.add_pixelsCount(pixelsCount);
  builder_.add_TopEdge(TopEdge);
  builder_.add_LeftEdge(LeftEdge);
  builder_.add_BottomEdge(BottomEdge);
  builder_.add_RightEdge(RightEdge);
  return builder_.Finish();
}

flatbuffers::Offset<ftkRegionOfInterest> CreateftkRegionOfInterest(flatbuffers::FlatBufferBuilder &_fbb, const ftkRegionOfInterestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FusionTrackFrameT : public flatbuffers::NativeTable {
  typedef FusionTrackFrame TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FusionTrackFrameT";
  }
  double timestamp;
  uint64_t serialNumber;
  uint64_t hardwareTimestampUS;
  uint64_t desynchroUS;
  uint32_t counter;
  uint32_t format;
  uint32_t width;
  uint32_t height;
  int32_t imageStrideInBytes;
  uint32_t imageHeaderVersion;
  int32_t imageHeaderStatus;
  std::string imageLeftPixels;
  uint32_t imageLeftPixelsVersion;
  int32_t imageLeftStatus;
  std::string imageRightPixels;
  uint32_t imageRightPixelsVersion;
  int32_t imageRightStatus;
  std::vector<std::unique_ptr<ftkRegionOfInterestT>> regionsOfInterestLeft;
  uint32_t regionsOfInterestLeftVersion;
  int32_t regionsOfInterestLeftStatus;
  std::vector<std::unique_ptr<ftkRegionOfInterestT>> regionsOfInterestRight;
  uint32_t regionsOfInterestRightVersion;
  int32_t regionsOfInterestRightStatus;
  std::vector<std::unique_ptr<ftk3DFiducialT>> threeDFiducials;
  uint32_t threeDFiducialsVersion;
  int32_t threeDFiducialsStatus;
  std::vector<std::unique_ptr<ftkMarkerT>> markers;
  uint32_t markersVersion;
  int32_t markersStatus;
  int32_t deviceType;
  int64_t ftkError;
  FusionTrackFrameT()
      : timestamp(0.0),
        serialNumber(0),
        hardwareTimestampUS(0),
        desynchroUS(0),
        counter(0),
        format(0),
        width(0),
        height(0),
        imageStrideInBytes(0),
        imageHeaderVersion(0),
        imageHeaderStatus(0),
        imageLeftPixelsVersion(0),
        imageLeftStatus(0),
        imageRightPixelsVersion(0),
        imageRightStatus(0),
        regionsOfInterestLeftVersion(0),
        regionsOfInterestLeftStatus(0),
        regionsOfInterestRightVersion(0),
        regionsOfInterestRightStatus(0),
        threeDFiducialsVersion(0),
        threeDFiducialsStatus(0),
        markersVersion(0),
        markersStatus(0),
        deviceType(0),
        ftkError(0) {
  }
};

/// Data for one frame capture
/// On the Atracsys FusionTrack optical tracker
/// look at ftkInterface.h for details
/// Frame class is defined in FusionTrack.hpp
struct FusionTrackFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FusionTrackFrameT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FusionTrackFrame";
  }
  enum {
    VT_TIMESTAMP = 4,
    VT_SERIALNUMBER = 6,
    VT_HARDWARETIMESTAMPUS = 8,
    VT_DESYNCHROUS = 10,
    VT_COUNTER = 12,
    VT_FORMAT = 14,
    VT_WIDTH = 16,
    VT_HEIGHT = 18,
    VT_IMAGESTRIDEINBYTES = 20,
    VT_IMAGEHEADERVERSION = 22,
    VT_IMAGEHEADERSTATUS = 24,
    VT_IMAGELEFTPIXELS = 26,
    VT_IMAGELEFTPIXELSVERSION = 28,
    VT_IMAGELEFTSTATUS = 30,
    VT_IMAGERIGHTPIXELS = 32,
    VT_IMAGERIGHTPIXELSVERSION = 34,
    VT_IMAGERIGHTSTATUS = 36,
    VT_REGIONSOFINTERESTLEFT = 38,
    VT_REGIONSOFINTERESTLEFTVERSION = 40,
    VT_REGIONSOFINTERESTLEFTSTATUS = 42,
    VT_REGIONSOFINTERESTRIGHT = 44,
    VT_REGIONSOFINTERESTRIGHTVERSION = 46,
    VT_REGIONSOFINTERESTRIGHTSTATUS = 48,
    VT_THREEDFIDUCIALS = 50,
    VT_THREEDFIDUCIALSVERSION = 52,
    VT_THREEDFIDUCIALSSTATUS = 54,
    VT_MARKERS = 56,
    VT_MARKERSVERSION = 58,
    VT_MARKERSSTATUS = 60,
    VT_DEVICETYPE = 62,
    VT_FTKERROR = 64
  };
  double timestamp() const {
    return GetField<double>(VT_TIMESTAMP, 0.0);
  }
  uint64_t serialNumber() const {
    return GetField<uint64_t>(VT_SERIALNUMBER, 0);
  }
  uint64_t hardwareTimestampUS() const {
    return GetField<uint64_t>(VT_HARDWARETIMESTAMPUS, 0);
  }
  uint64_t desynchroUS() const {
    return GetField<uint64_t>(VT_DESYNCHROUS, 0);
  }
  uint32_t counter() const {
    return GetField<uint32_t>(VT_COUNTER, 0);
  }
  uint32_t format() const {
    return GetField<uint32_t>(VT_FORMAT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  int32_t imageStrideInBytes() const {
    return GetField<int32_t>(VT_IMAGESTRIDEINBYTES, 0);
  }
  uint32_t imageHeaderVersion() const {
    return GetField<uint32_t>(VT_IMAGEHEADERVERSION, 0);
  }
  int32_t imageHeaderStatus() const {
    return GetField<int32_t>(VT_IMAGEHEADERSTATUS, 0);
  }
  const flatbuffers::String *imageLeftPixels() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGELEFTPIXELS);
  }
  uint32_t imageLeftPixelsVersion() const {
    return GetField<uint32_t>(VT_IMAGELEFTPIXELSVERSION, 0);
  }
  int32_t imageLeftStatus() const {
    return GetField<int32_t>(VT_IMAGELEFTSTATUS, 0);
  }
  const flatbuffers::String *imageRightPixels() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGERIGHTPIXELS);
  }
  uint32_t imageRightPixelsVersion() const {
    return GetField<uint32_t>(VT_IMAGERIGHTPIXELSVERSION, 0);
  }
  int32_t imageRightStatus() const {
    return GetField<int32_t>(VT_IMAGERIGHTSTATUS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>> *regionsOfInterestLeft() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>> *>(VT_REGIONSOFINTERESTLEFT);
  }
  uint32_t regionsOfInterestLeftVersion() const {
    return GetField<uint32_t>(VT_REGIONSOFINTERESTLEFTVERSION, 0);
  }
  int32_t regionsOfInterestLeftStatus() const {
    return GetField<int32_t>(VT_REGIONSOFINTERESTLEFTSTATUS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>> *regionsOfInterestRight() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>> *>(VT_REGIONSOFINTERESTRIGHT);
  }
  uint32_t regionsOfInterestRightVersion() const {
    return GetField<uint32_t>(VT_REGIONSOFINTERESTRIGHTVERSION, 0);
  }
  int32_t regionsOfInterestRightStatus() const {
    return GetField<int32_t>(VT_REGIONSOFINTERESTRIGHTSTATUS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ftk3DFiducial>> *threeDFiducials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ftk3DFiducial>> *>(VT_THREEDFIDUCIALS);
  }
  uint32_t threeDFiducialsVersion() const {
    return GetField<uint32_t>(VT_THREEDFIDUCIALSVERSION, 0);
  }
  int32_t threeDFiducialsStatus() const {
    return GetField<int32_t>(VT_THREEDFIDUCIALSSTATUS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ftkMarker>> *markers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ftkMarker>> *>(VT_MARKERS);
  }
  uint32_t markersVersion() const {
    return GetField<uint32_t>(VT_MARKERSVERSION, 0);
  }
  int32_t markersStatus() const {
    return GetField<int32_t>(VT_MARKERSSTATUS, 0);
  }
  int32_t deviceType() const {
    return GetField<int32_t>(VT_DEVICETYPE, 0);
  }
  int64_t ftkError() const {
    return GetField<int64_t>(VT_FTKERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint64_t>(verifier, VT_SERIALNUMBER) &&
           VerifyField<uint64_t>(verifier, VT_HARDWARETIMESTAMPUS) &&
           VerifyField<uint64_t>(verifier, VT_DESYNCHROUS) &&
           VerifyField<uint32_t>(verifier, VT_COUNTER) &&
           VerifyField<uint32_t>(verifier, VT_FORMAT) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_IMAGESTRIDEINBYTES) &&
           VerifyField<uint32_t>(verifier, VT_IMAGEHEADERVERSION) &&
           VerifyField<int32_t>(verifier, VT_IMAGEHEADERSTATUS) &&
           VerifyOffset(verifier, VT_IMAGELEFTPIXELS) &&
           verifier.Verify(imageLeftPixels()) &&
           VerifyField<uint32_t>(verifier, VT_IMAGELEFTPIXELSVERSION) &&
           VerifyField<int32_t>(verifier, VT_IMAGELEFTSTATUS) &&
           VerifyOffset(verifier, VT_IMAGERIGHTPIXELS) &&
           verifier.Verify(imageRightPixels()) &&
           VerifyField<uint32_t>(verifier, VT_IMAGERIGHTPIXELSVERSION) &&
           VerifyField<int32_t>(verifier, VT_IMAGERIGHTSTATUS) &&
           VerifyOffset(verifier, VT_REGIONSOFINTERESTLEFT) &&
           verifier.Verify(regionsOfInterestLeft()) &&
           verifier.VerifyVectorOfTables(regionsOfInterestLeft()) &&
           VerifyField<uint32_t>(verifier, VT_REGIONSOFINTERESTLEFTVERSION) &&
           VerifyField<int32_t>(verifier, VT_REGIONSOFINTERESTLEFTSTATUS) &&
           VerifyOffset(verifier, VT_REGIONSOFINTERESTRIGHT) &&
           verifier.Verify(regionsOfInterestRight()) &&
           verifier.VerifyVectorOfTables(regionsOfInterestRight()) &&
           VerifyField<uint32_t>(verifier, VT_REGIONSOFINTERESTRIGHTVERSION) &&
           VerifyField<int32_t>(verifier, VT_REGIONSOFINTERESTRIGHTSTATUS) &&
           VerifyOffset(verifier, VT_THREEDFIDUCIALS) &&
           verifier.Verify(threeDFiducials()) &&
           verifier.VerifyVectorOfTables(threeDFiducials()) &&
           VerifyField<uint32_t>(verifier, VT_THREEDFIDUCIALSVERSION) &&
           VerifyField<int32_t>(verifier, VT_THREEDFIDUCIALSSTATUS) &&
           VerifyOffset(verifier, VT_MARKERS) &&
           verifier.Verify(markers()) &&
           verifier.VerifyVectorOfTables(markers()) &&
           VerifyField<uint32_t>(verifier, VT_MARKERSVERSION) &&
           VerifyField<int32_t>(verifier, VT_MARKERSSTATUS) &&
           VerifyField<int32_t>(verifier, VT_DEVICETYPE) &&
           VerifyField<int64_t>(verifier, VT_FTKERROR) &&
           verifier.EndTable();
  }
  FusionTrackFrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FusionTrackFrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FusionTrackFrame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FusionTrackFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(double timestamp) {
    fbb_.AddElement<double>(FusionTrackFrame::VT_TIMESTAMP, timestamp, 0.0);
  }
  void add_serialNumber(uint64_t serialNumber) {
    fbb_.AddElement<uint64_t>(FusionTrackFrame::VT_SERIALNUMBER, serialNumber, 0);
  }
  void add_hardwareTimestampUS(uint64_t hardwareTimestampUS) {
    fbb_.AddElement<uint64_t>(FusionTrackFrame::VT_HARDWARETIMESTAMPUS, hardwareTimestampUS, 0);
  }
  void add_desynchroUS(uint64_t desynchroUS) {
    fbb_.AddElement<uint64_t>(FusionTrackFrame::VT_DESYNCHROUS, desynchroUS, 0);
  }
  void add_counter(uint32_t counter) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_COUNTER, counter, 0);
  }
  void add_format(uint32_t format) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_FORMAT, format, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_HEIGHT, height, 0);
  }
  void add_imageStrideInBytes(int32_t imageStrideInBytes) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_IMAGESTRIDEINBYTES, imageStrideInBytes, 0);
  }
  void add_imageHeaderVersion(uint32_t imageHeaderVersion) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_IMAGEHEADERVERSION, imageHeaderVersion, 0);
  }
  void add_imageHeaderStatus(int32_t imageHeaderStatus) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_IMAGEHEADERSTATUS, imageHeaderStatus, 0);
  }
  void add_imageLeftPixels(flatbuffers::Offset<flatbuffers::String> imageLeftPixels) {
    fbb_.AddOffset(FusionTrackFrame::VT_IMAGELEFTPIXELS, imageLeftPixels);
  }
  void add_imageLeftPixelsVersion(uint32_t imageLeftPixelsVersion) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_IMAGELEFTPIXELSVERSION, imageLeftPixelsVersion, 0);
  }
  void add_imageLeftStatus(int32_t imageLeftStatus) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_IMAGELEFTSTATUS, imageLeftStatus, 0);
  }
  void add_imageRightPixels(flatbuffers::Offset<flatbuffers::String> imageRightPixels) {
    fbb_.AddOffset(FusionTrackFrame::VT_IMAGERIGHTPIXELS, imageRightPixels);
  }
  void add_imageRightPixelsVersion(uint32_t imageRightPixelsVersion) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_IMAGERIGHTPIXELSVERSION, imageRightPixelsVersion, 0);
  }
  void add_imageRightStatus(int32_t imageRightStatus) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_IMAGERIGHTSTATUS, imageRightStatus, 0);
  }
  void add_regionsOfInterestLeft(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>>> regionsOfInterestLeft) {
    fbb_.AddOffset(FusionTrackFrame::VT_REGIONSOFINTERESTLEFT, regionsOfInterestLeft);
  }
  void add_regionsOfInterestLeftVersion(uint32_t regionsOfInterestLeftVersion) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_REGIONSOFINTERESTLEFTVERSION, regionsOfInterestLeftVersion, 0);
  }
  void add_regionsOfInterestLeftStatus(int32_t regionsOfInterestLeftStatus) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_REGIONSOFINTERESTLEFTSTATUS, regionsOfInterestLeftStatus, 0);
  }
  void add_regionsOfInterestRight(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>>> regionsOfInterestRight) {
    fbb_.AddOffset(FusionTrackFrame::VT_REGIONSOFINTERESTRIGHT, regionsOfInterestRight);
  }
  void add_regionsOfInterestRightVersion(uint32_t regionsOfInterestRightVersion) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_REGIONSOFINTERESTRIGHTVERSION, regionsOfInterestRightVersion, 0);
  }
  void add_regionsOfInterestRightStatus(int32_t regionsOfInterestRightStatus) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_REGIONSOFINTERESTRIGHTSTATUS, regionsOfInterestRightStatus, 0);
  }
  void add_threeDFiducials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftk3DFiducial>>> threeDFiducials) {
    fbb_.AddOffset(FusionTrackFrame::VT_THREEDFIDUCIALS, threeDFiducials);
  }
  void add_threeDFiducialsVersion(uint32_t threeDFiducialsVersion) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_THREEDFIDUCIALSVERSION, threeDFiducialsVersion, 0);
  }
  void add_threeDFiducialsStatus(int32_t threeDFiducialsStatus) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_THREEDFIDUCIALSSTATUS, threeDFiducialsStatus, 0);
  }
  void add_markers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkMarker>>> markers) {
    fbb_.AddOffset(FusionTrackFrame::VT_MARKERS, markers);
  }
  void add_markersVersion(uint32_t markersVersion) {
    fbb_.AddElement<uint32_t>(FusionTrackFrame::VT_MARKERSVERSION, markersVersion, 0);
  }
  void add_markersStatus(int32_t markersStatus) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_MARKERSSTATUS, markersStatus, 0);
  }
  void add_deviceType(int32_t deviceType) {
    fbb_.AddElement<int32_t>(FusionTrackFrame::VT_DEVICETYPE, deviceType, 0);
  }
  void add_ftkError(int64_t ftkError) {
    fbb_.AddElement<int64_t>(FusionTrackFrame::VT_FTKERROR, ftkError, 0);
  }
  explicit FusionTrackFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FusionTrackFrameBuilder &operator=(const FusionTrackFrameBuilder &);
  flatbuffers::Offset<FusionTrackFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusionTrackFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusionTrackFrame> CreateFusionTrackFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    double timestamp = 0.0,
    uint64_t serialNumber = 0,
    uint64_t hardwareTimestampUS = 0,
    uint64_t desynchroUS = 0,
    uint32_t counter = 0,
    uint32_t format = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    int32_t imageStrideInBytes = 0,
    uint32_t imageHeaderVersion = 0,
    int32_t imageHeaderStatus = 0,
    flatbuffers::Offset<flatbuffers::String> imageLeftPixels = 0,
    uint32_t imageLeftPixelsVersion = 0,
    int32_t imageLeftStatus = 0,
    flatbuffers::Offset<flatbuffers::String> imageRightPixels = 0,
    uint32_t imageRightPixelsVersion = 0,
    int32_t imageRightStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>>> regionsOfInterestLeft = 0,
    uint32_t regionsOfInterestLeftVersion = 0,
    int32_t regionsOfInterestLeftStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkRegionOfInterest>>> regionsOfInterestRight = 0,
    uint32_t regionsOfInterestRightVersion = 0,
    int32_t regionsOfInterestRightStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftk3DFiducial>>> threeDFiducials = 0,
    uint32_t threeDFiducialsVersion = 0,
    int32_t threeDFiducialsStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkMarker>>> markers = 0,
    uint32_t markersVersion = 0,
    int32_t markersStatus = 0,
    int32_t deviceType = 0,
    int64_t ftkError = 0) {
  FusionTrackFrameBuilder builder_(_fbb);
  builder_.add_ftkError(ftkError);
  builder_.add_desynchroUS(desynchroUS);
  builder_.add_hardwareTimestampUS(hardwareTimestampUS);
  builder_.add_serialNumber(serialNumber);
  builder_.add_timestamp(timestamp);
  builder_.add_deviceType(deviceType);
  builder_.add_markersStatus(markersStatus);
  builder_.add_markersVersion(markersVersion);
  builder_.add_markers(markers);
  builder_.add_threeDFiducialsStatus(threeDFiducialsStatus);
  builder_.add_threeDFiducialsVersion(threeDFiducialsVersion);
  builder_.add_threeDFiducials(threeDFiducials);
  builder_.add_regionsOfInterestRightStatus(regionsOfInterestRightStatus);
  builder_.add_regionsOfInterestRightVersion(regionsOfInterestRightVersion);
  builder_.add_regionsOfInterestRight(regionsOfInterestRight);
  builder_.add_regionsOfInterestLeftStatus(regionsOfInterestLeftStatus);
  builder_.add_regionsOfInterestLeftVersion(regionsOfInterestLeftVersion);
  builder_.add_regionsOfInterestLeft(regionsOfInterestLeft);
  builder_.add_imageRightStatus(imageRightStatus);
  builder_.add_imageRightPixelsVersion(imageRightPixelsVersion);
  builder_.add_imageRightPixels(imageRightPixels);
  builder_.add_imageLeftStatus(imageLeftStatus);
  builder_.add_imageLeftPixelsVersion(imageLeftPixelsVersion);
  builder_.add_imageLeftPixels(imageLeftPixels);
  builder_.add_imageHeaderStatus(imageHeaderStatus);
  builder_.add_imageHeaderVersion(imageHeaderVersion);
  builder_.add_imageStrideInBytes(imageStrideInBytes);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_format(format);
  builder_.add_counter(counter);
  return builder_.Finish();
}

inline flatbuffers::Offset<FusionTrackFrame> CreateFusionTrackFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double timestamp = 0.0,
    uint64_t serialNumber = 0,
    uint64_t hardwareTimestampUS = 0,
    uint64_t desynchroUS = 0,
    uint32_t counter = 0,
    uint32_t format = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    int32_t imageStrideInBytes = 0,
    uint32_t imageHeaderVersion = 0,
    int32_t imageHeaderStatus = 0,
    const char *imageLeftPixels = nullptr,
    uint32_t imageLeftPixelsVersion = 0,
    int32_t imageLeftStatus = 0,
    const char *imageRightPixels = nullptr,
    uint32_t imageRightPixelsVersion = 0,
    int32_t imageRightStatus = 0,
    const std::vector<flatbuffers::Offset<ftkRegionOfInterest>> *regionsOfInterestLeft = nullptr,
    uint32_t regionsOfInterestLeftVersion = 0,
    int32_t regionsOfInterestLeftStatus = 0,
    const std::vector<flatbuffers::Offset<ftkRegionOfInterest>> *regionsOfInterestRight = nullptr,
    uint32_t regionsOfInterestRightVersion = 0,
    int32_t regionsOfInterestRightStatus = 0,
    const std::vector<flatbuffers::Offset<ftk3DFiducial>> *threeDFiducials = nullptr,
    uint32_t threeDFiducialsVersion = 0,
    int32_t threeDFiducialsStatus = 0,
    const std::vector<flatbuffers::Offset<ftkMarker>> *markers = nullptr,
    uint32_t markersVersion = 0,
    int32_t markersStatus = 0,
    int32_t deviceType = 0,
    int64_t ftkError = 0) {
  return grl::flatbuffer::CreateFusionTrackFrame(
      _fbb,
      timestamp,
      serialNumber,
      hardwareTimestampUS,
      desynchroUS,
      counter,
      format,
      width,
      height,
      imageStrideInBytes,
      imageHeaderVersion,
      imageHeaderStatus,
      imageLeftPixels ? _fbb.CreateString(imageLeftPixels) : 0,
      imageLeftPixelsVersion,
      imageLeftStatus,
      imageRightPixels ? _fbb.CreateString(imageRightPixels) : 0,
      imageRightPixelsVersion,
      imageRightStatus,
      regionsOfInterestLeft ? _fbb.CreateVector<flatbuffers::Offset<ftkRegionOfInterest>>(*regionsOfInterestLeft) : 0,
      regionsOfInterestLeftVersion,
      regionsOfInterestLeftStatus,
      regionsOfInterestRight ? _fbb.CreateVector<flatbuffers::Offset<ftkRegionOfInterest>>(*regionsOfInterestRight) : 0,
      regionsOfInterestRightVersion,
      regionsOfInterestRightStatus,
      threeDFiducials ? _fbb.CreateVector<flatbuffers::Offset<ftk3DFiducial>>(*threeDFiducials) : 0,
      threeDFiducialsVersion,
      threeDFiducialsStatus,
      markers ? _fbb.CreateVector<flatbuffers::Offset<ftkMarker>>(*markers) : 0,
      markersVersion,
      markersStatus,
      deviceType,
      ftkError);
}

flatbuffers::Offset<FusionTrackFrame> CreateFusionTrackFrame(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FusionTrackParametersT : public flatbuffers::NativeTable {
  typedef FusionTrackParameters TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FusionTrackParametersT";
  }
  std::string name;
  std::string deviceClockID;
  std::string localClockID;
  std::vector<std::unique_ptr<ftkGeometryT>> geometries;
  std::vector<std::string> geometryFilenames;
  std::string geometryDir;
  std::vector<uint64_t> TrackerDeviceIDs;
  std::vector<uint64_t> markerIDs;
  std::vector<std::string> markerNames;
  std::vector<uint64_t> m_deviceSerialNumbers;
  std::vector<uint8_t> m_device_types;
  FusionTrackParametersT() {
  }
};

struct FusionTrackParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FusionTrackParametersT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FusionTrackParameters";
  }
  enum {
    VT_NAME = 4,
    VT_DEVICECLOCKID = 6,
    VT_LOCALCLOCKID = 8,
    VT_GEOMETRIES = 10,
    VT_GEOMETRYFILENAMES = 12,
    VT_GEOMETRYDIR = 14,
    VT_TRACKERDEVICEIDS = 16,
    VT_MARKERIDS = 18,
    VT_MARKERNAMES = 20,
    VT_M_DEVICESERIALNUMBERS = 22,
    VT_M_DEVICE_TYPES = 24
  };
  /// Name for this connection / FusionTrack driver instance
  /// useful for debugging and when multiple data sources are used
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// Name for the clock on the FusionTrack
  /// Useful for timing calculations and debugging.
  const flatbuffers::String *deviceClockID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICECLOCKID);
  }
  /// Name for the local clock on which this driver runs
  /// Useful for timing calculations and debugging.
  const flatbuffers::String *localClockID() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALCLOCKID);
  }
  /// dimensions of the markers that may be present
  const flatbuffers::Vector<flatbuffers::Offset<ftkGeometry>> *geometries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ftkGeometry>> *>(VT_GEOMETRIES);
  }
  /// Geometries aka fiducials aka markers to be loaded from ini files.
  /// The data loaded should not repeat IDs from MarkerIDs.
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *geometryFilenames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_GEOMETRYFILENAMES);
  }
  /// Path to the directory with the marker ini files listed above
  /// Uses the default current working directory if empty
  /// geometryDir:[string];
  const flatbuffers::String *geometryDir() const {
    return GetPointer<const flatbuffers::String *>(VT_GEOMETRYDIR);
  }
  /// Optional list of optical tracker device ids to expect
  /// will be loaded automatically if empty
  const flatbuffers::Vector<uint64_t> *TrackerDeviceIDs() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_TRACKERDEVICEIDS);
  }
  /// Marker geometry unique integer IDs
  const flatbuffers::Vector<uint64_t> *markerIDs() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_MARKERIDS);
  }
  /// Optional Marker geometry names with one for each ID, none otherwise
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *markerNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MARKERNAMES);
  }
  const flatbuffers::Vector<uint64_t> *m_deviceSerialNumbers() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_M_DEVICESERIALNUMBERS);
  }
  const flatbuffers::Vector<uint8_t> *m_device_types() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_M_DEVICE_TYPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DEVICECLOCKID) &&
           verifier.Verify(deviceClockID()) &&
           VerifyOffset(verifier, VT_LOCALCLOCKID) &&
           verifier.Verify(localClockID()) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.Verify(geometries()) &&
           verifier.VerifyVectorOfTables(geometries()) &&
           VerifyOffset(verifier, VT_GEOMETRYFILENAMES) &&
           verifier.Verify(geometryFilenames()) &&
           verifier.VerifyVectorOfStrings(geometryFilenames()) &&
           VerifyOffset(verifier, VT_GEOMETRYDIR) &&
           verifier.Verify(geometryDir()) &&
           VerifyOffset(verifier, VT_TRACKERDEVICEIDS) &&
           verifier.Verify(TrackerDeviceIDs()) &&
           VerifyOffset(verifier, VT_MARKERIDS) &&
           verifier.Verify(markerIDs()) &&
           VerifyOffset(verifier, VT_MARKERNAMES) &&
           verifier.Verify(markerNames()) &&
           verifier.VerifyVectorOfStrings(markerNames()) &&
           VerifyOffset(verifier, VT_M_DEVICESERIALNUMBERS) &&
           verifier.Verify(m_deviceSerialNumbers()) &&
           VerifyOffset(verifier, VT_M_DEVICE_TYPES) &&
           verifier.Verify(m_device_types()) &&
           verifier.EndTable();
  }
  FusionTrackParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FusionTrackParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FusionTrackParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FusionTrackParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FusionTrackParameters::VT_NAME, name);
  }
  void add_deviceClockID(flatbuffers::Offset<flatbuffers::String> deviceClockID) {
    fbb_.AddOffset(FusionTrackParameters::VT_DEVICECLOCKID, deviceClockID);
  }
  void add_localClockID(flatbuffers::Offset<flatbuffers::String> localClockID) {
    fbb_.AddOffset(FusionTrackParameters::VT_LOCALCLOCKID, localClockID);
  }
  void add_geometries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkGeometry>>> geometries) {
    fbb_.AddOffset(FusionTrackParameters::VT_GEOMETRIES, geometries);
  }
  void add_geometryFilenames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> geometryFilenames) {
    fbb_.AddOffset(FusionTrackParameters::VT_GEOMETRYFILENAMES, geometryFilenames);
  }
  void add_geometryDir(flatbuffers::Offset<flatbuffers::String> geometryDir) {
    fbb_.AddOffset(FusionTrackParameters::VT_GEOMETRYDIR, geometryDir);
  }
  void add_TrackerDeviceIDs(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> TrackerDeviceIDs) {
    fbb_.AddOffset(FusionTrackParameters::VT_TRACKERDEVICEIDS, TrackerDeviceIDs);
  }
  void add_markerIDs(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> markerIDs) {
    fbb_.AddOffset(FusionTrackParameters::VT_MARKERIDS, markerIDs);
  }
  void add_markerNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> markerNames) {
    fbb_.AddOffset(FusionTrackParameters::VT_MARKERNAMES, markerNames);
  }
  void add_m_deviceSerialNumbers(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> m_deviceSerialNumbers) {
    fbb_.AddOffset(FusionTrackParameters::VT_M_DEVICESERIALNUMBERS, m_deviceSerialNumbers);
  }
  void add_m_device_types(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> m_device_types) {
    fbb_.AddOffset(FusionTrackParameters::VT_M_DEVICE_TYPES, m_device_types);
  }
  explicit FusionTrackParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FusionTrackParametersBuilder &operator=(const FusionTrackParametersBuilder &);
  flatbuffers::Offset<FusionTrackParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusionTrackParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusionTrackParameters> CreateFusionTrackParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> deviceClockID = 0,
    flatbuffers::Offset<flatbuffers::String> localClockID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ftkGeometry>>> geometries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> geometryFilenames = 0,
    flatbuffers::Offset<flatbuffers::String> geometryDir = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> TrackerDeviceIDs = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> markerIDs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> markerNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> m_deviceSerialNumbers = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> m_device_types = 0) {
  FusionTrackParametersBuilder builder_(_fbb);
  builder_.add_m_device_types(m_device_types);
  builder_.add_m_deviceSerialNumbers(m_deviceSerialNumbers);
  builder_.add_markerNames(markerNames);
  builder_.add_markerIDs(markerIDs);
  builder_.add_TrackerDeviceIDs(TrackerDeviceIDs);
  builder_.add_geometryDir(geometryDir);
  builder_.add_geometryFilenames(geometryFilenames);
  builder_.add_geometries(geometries);
  builder_.add_localClockID(localClockID);
  builder_.add_deviceClockID(deviceClockID);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FusionTrackParameters> CreateFusionTrackParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *deviceClockID = nullptr,
    const char *localClockID = nullptr,
    const std::vector<flatbuffers::Offset<ftkGeometry>> *geometries = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *geometryFilenames = nullptr,
    const char *geometryDir = nullptr,
    const std::vector<uint64_t> *TrackerDeviceIDs = nullptr,
    const std::vector<uint64_t> *markerIDs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *markerNames = nullptr,
    const std::vector<uint64_t> *m_deviceSerialNumbers = nullptr,
    const std::vector<uint8_t> *m_device_types = nullptr) {
  return grl::flatbuffer::CreateFusionTrackParameters(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      deviceClockID ? _fbb.CreateString(deviceClockID) : 0,
      localClockID ? _fbb.CreateString(localClockID) : 0,
      geometries ? _fbb.CreateVector<flatbuffers::Offset<ftkGeometry>>(*geometries) : 0,
      geometryFilenames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*geometryFilenames) : 0,
      geometryDir ? _fbb.CreateString(geometryDir) : 0,
      TrackerDeviceIDs ? _fbb.CreateVector<uint64_t>(*TrackerDeviceIDs) : 0,
      markerIDs ? _fbb.CreateVector<uint64_t>(*markerIDs) : 0,
      markerNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*markerNames) : 0,
      m_deviceSerialNumbers ? _fbb.CreateVector<uint64_t>(*m_deviceSerialNumbers) : 0,
      m_device_types ? _fbb.CreateVector<uint8_t>(*m_device_types) : 0);
}

flatbuffers::Offset<FusionTrackParameters> CreateFusionTrackParameters(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FusionTrackMessageT : public flatbuffers::NativeTable {
  typedef FusionTrackMessage TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FusionTrackMessageT";
  }
  double timestamp;
  std::unique_ptr<FusionTrackParametersT> parameters;
  std::unique_ptr<TimeEventT> timeEvent;
  std::unique_ptr<FusionTrackFrameT> frame;
  FusionTrackMessageT()
      : timestamp(0.0) {
  }
};

struct FusionTrackMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FusionTrackMessageT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FusionTrackMessage";
  }
  enum {
    VT_TIMESTAMP = 4,
    VT_PARAMETERS = 6,
    VT_TIMEEVENT = 8,
    VT_FRAME = 10
  };
  double timestamp() const {
    return GetField<double>(VT_TIMESTAMP, 0.0);
  }
  const FusionTrackParameters *parameters() const {
    return GetPointer<const FusionTrackParameters *>(VT_PARAMETERS);
  }
  const TimeEvent *timeEvent() const {
    return GetPointer<const TimeEvent *>(VT_TIMEEVENT);
  }
  const FusionTrackFrame *frame() const {
    return GetPointer<const FusionTrackFrame *>(VT_FRAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyTable(parameters()) &&
           VerifyOffset(verifier, VT_TIMEEVENT) &&
           verifier.VerifyTable(timeEvent()) &&
           VerifyOffset(verifier, VT_FRAME) &&
           verifier.VerifyTable(frame()) &&
           verifier.EndTable();
  }
  FusionTrackMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FusionTrackMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FusionTrackMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FusionTrackMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(double timestamp) {
    fbb_.AddElement<double>(FusionTrackMessage::VT_TIMESTAMP, timestamp, 0.0);
  }
  void add_parameters(flatbuffers::Offset<FusionTrackParameters> parameters) {
    fbb_.AddOffset(FusionTrackMessage::VT_PARAMETERS, parameters);
  }
  void add_timeEvent(flatbuffers::Offset<TimeEvent> timeEvent) {
    fbb_.AddOffset(FusionTrackMessage::VT_TIMEEVENT, timeEvent);
  }
  void add_frame(flatbuffers::Offset<FusionTrackFrame> frame) {
    fbb_.AddOffset(FusionTrackMessage::VT_FRAME, frame);
  }
  explicit FusionTrackMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FusionTrackMessageBuilder &operator=(const FusionTrackMessageBuilder &);
  flatbuffers::Offset<FusionTrackMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusionTrackMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusionTrackMessage> CreateFusionTrackMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    double timestamp = 0.0,
    flatbuffers::Offset<FusionTrackParameters> parameters = 0,
    flatbuffers::Offset<TimeEvent> timeEvent = 0,
    flatbuffers::Offset<FusionTrackFrame> frame = 0) {
  FusionTrackMessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_frame(frame);
  builder_.add_timeEvent(timeEvent);
  builder_.add_parameters(parameters);
  return builder_.Finish();
}

flatbuffers::Offset<FusionTrackMessage> CreateFusionTrackMessage(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ftkGeometryT *ftkGeometry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ftkGeometryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ftkGeometry::UnPackTo(ftkGeometryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = geometryID(); _o->geometryID = _e; };
  { auto _e = version(); _o->version = _e; };
  { auto _e = positions(); if (_e) { _o->positions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->positions[_i] = *_e->Get(_i); } } };
}

inline flatbuffers::Offset<ftkGeometry> ftkGeometry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftkGeometryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateftkGeometry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ftkGeometry> CreateftkGeometry(flatbuffers::FlatBufferBuilder &_fbb, const ftkGeometryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ftkGeometryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _geometryID = _o->geometryID;
  auto _version = _o->version;
  auto _positions = _o->positions.size() ? _fbb.CreateVectorOfStructs(_o->positions) : 0;
  return grl::flatbuffer::CreateftkGeometry(
      _fbb,
      _name,
      _geometryID,
      _version,
      _positions);
}

inline ftkMarkerT *ftkMarker::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ftkMarkerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ftkMarker::UnPackTo(ftkMarkerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = ID(); _o->ID = _e; };
  { auto _e = geometryID(); _o->geometryID = _e; };
  { auto _e = geometryPresenceMask(); if (_e) { _o->geometryPresenceMask.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->geometryPresenceMask[_i] = _e->Get(_i); } } };
  { auto _e = transform(); if (_e) _o->transform = std::unique_ptr<Pose>(new Pose(*_e)); };
}

inline flatbuffers::Offset<ftkMarker> ftkMarker::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftkMarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateftkMarker(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ftkMarker> CreateftkMarker(flatbuffers::FlatBufferBuilder &_fbb, const ftkMarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ftkMarkerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _ID = _o->ID;
  auto _geometryID = _o->geometryID;
  auto _geometryPresenceMask = _o->geometryPresenceMask.size() ? _fbb.CreateVector(_o->geometryPresenceMask) : 0;
  auto _transform = _o->transform ? _o->transform.get() : 0;
  return grl::flatbuffer::CreateftkMarker(
      _fbb,
      _name,
      _ID,
      _geometryID,
      _geometryPresenceMask,
      _transform);
}

inline ftk3DFiducialT *ftk3DFiducial::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ftk3DFiducialT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ftk3DFiducial::UnPackTo(ftk3DFiducialT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = markerID(); _o->markerID = _e; };
  { auto _e = leftIndex(); _o->leftIndex = _e; };
  { auto _e = rightIndex(); _o->rightIndex = _e; };
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<Vector3d>(new Vector3d(*_e)); };
  { auto _e = epipolarErrorPixels(); _o->epipolarErrorPixels = _e; };
  { auto _e = triangulationError(); _o->triangulationError = _e; };
  { auto _e = probability(); _o->probability = _e; };
}

inline flatbuffers::Offset<ftk3DFiducial> ftk3DFiducial::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftk3DFiducialT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createftk3DFiducial(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ftk3DFiducial> Createftk3DFiducial(flatbuffers::FlatBufferBuilder &_fbb, const ftk3DFiducialT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ftk3DFiducialT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _markerID = _o->markerID;
  auto _leftIndex = _o->leftIndex;
  auto _rightIndex = _o->rightIndex;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _epipolarErrorPixels = _o->epipolarErrorPixels;
  auto _triangulationError = _o->triangulationError;
  auto _probability = _o->probability;
  return grl::flatbuffer::Createftk3DFiducial(
      _fbb,
      _markerID,
      _leftIndex,
      _rightIndex,
      _position,
      _epipolarErrorPixels,
      _triangulationError,
      _probability);
}

inline ftkRegionOfInterestT *ftkRegionOfInterest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ftkRegionOfInterestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ftkRegionOfInterest::UnPackTo(ftkRegionOfInterestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = centerXPixels(); _o->centerXPixels = _e; };
  { auto _e = centerYPixels(); _o->centerYPixels = _e; };
  { auto _e = RightEdge(); _o->RightEdge = _e; };
  { auto _e = BottomEdge(); _o->BottomEdge = _e; };
  { auto _e = LeftEdge(); _o->LeftEdge = _e; };
  { auto _e = TopEdge(); _o->TopEdge = _e; };
  { auto _e = pixelsCount(); _o->pixelsCount = _e; };
  { auto _e = probability(); _o->probability = _e; };
}

inline flatbuffers::Offset<ftkRegionOfInterest> ftkRegionOfInterest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ftkRegionOfInterestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateftkRegionOfInterest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ftkRegionOfInterest> CreateftkRegionOfInterest(flatbuffers::FlatBufferBuilder &_fbb, const ftkRegionOfInterestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ftkRegionOfInterestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _centerXPixels = _o->centerXPixels;
  auto _centerYPixels = _o->centerYPixels;
  auto _RightEdge = _o->RightEdge;
  auto _BottomEdge = _o->BottomEdge;
  auto _LeftEdge = _o->LeftEdge;
  auto _TopEdge = _o->TopEdge;
  auto _pixelsCount = _o->pixelsCount;
  auto _probability = _o->probability;
  return grl::flatbuffer::CreateftkRegionOfInterest(
      _fbb,
      _centerXPixels,
      _centerYPixels,
      _RightEdge,
      _BottomEdge,
      _LeftEdge,
      _TopEdge,
      _pixelsCount,
      _probability);
}

inline FusionTrackFrameT *FusionTrackFrame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FusionTrackFrameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FusionTrackFrame::UnPackTo(FusionTrackFrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = timestamp(); _o->timestamp = _e; };
  { auto _e = serialNumber(); _o->serialNumber = _e; };
  { auto _e = hardwareTimestampUS(); _o->hardwareTimestampUS = _e; };
  { auto _e = desynchroUS(); _o->desynchroUS = _e; };
  { auto _e = counter(); _o->counter = _e; };
  { auto _e = format(); _o->format = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = height(); _o->height = _e; };
  { auto _e = imageStrideInBytes(); _o->imageStrideInBytes = _e; };
  { auto _e = imageHeaderVersion(); _o->imageHeaderVersion = _e; };
  { auto _e = imageHeaderStatus(); _o->imageHeaderStatus = _e; };
  { auto _e = imageLeftPixels(); if (_e) _o->imageLeftPixels = _e->str(); };
  { auto _e = imageLeftPixelsVersion(); _o->imageLeftPixelsVersion = _e; };
  { auto _e = imageLeftStatus(); _o->imageLeftStatus = _e; };
  { auto _e = imageRightPixels(); if (_e) _o->imageRightPixels = _e->str(); };
  { auto _e = imageRightPixelsVersion(); _o->imageRightPixelsVersion = _e; };
  { auto _e = imageRightStatus(); _o->imageRightStatus = _e; };
  { auto _e = regionsOfInterestLeft(); if (_e) { _o->regionsOfInterestLeft.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regionsOfInterestLeft[_i] = std::unique_ptr<ftkRegionOfInterestT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = regionsOfInterestLeftVersion(); _o->regionsOfInterestLeftVersion = _e; };
  { auto _e = regionsOfInterestLeftStatus(); _o->regionsOfInterestLeftStatus = _e; };
  { auto _e = regionsOfInterestRight(); if (_e) { _o->regionsOfInterestRight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regionsOfInterestRight[_i] = std::unique_ptr<ftkRegionOfInterestT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = regionsOfInterestRightVersion(); _o->regionsOfInterestRightVersion = _e; };
  { auto _e = regionsOfInterestRightStatus(); _o->regionsOfInterestRightStatus = _e; };
  { auto _e = threeDFiducials(); if (_e) { _o->threeDFiducials.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->threeDFiducials[_i] = std::unique_ptr<ftk3DFiducialT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = threeDFiducialsVersion(); _o->threeDFiducialsVersion = _e; };
  { auto _e = threeDFiducialsStatus(); _o->threeDFiducialsStatus = _e; };
  { auto _e = markers(); if (_e) { _o->markers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->markers[_i] = std::unique_ptr<ftkMarkerT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = markersVersion(); _o->markersVersion = _e; };
  { auto _e = markersStatus(); _o->markersStatus = _e; };
  { auto _e = deviceType(); _o->deviceType = _e; };
  { auto _e = ftkError(); _o->ftkError = _e; };
}

inline flatbuffers::Offset<FusionTrackFrame> FusionTrackFrame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFusionTrackFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FusionTrackFrame> CreateFusionTrackFrame(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FusionTrackFrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp = _o->timestamp;
  auto _serialNumber = _o->serialNumber;
  auto _hardwareTimestampUS = _o->hardwareTimestampUS;
  auto _desynchroUS = _o->desynchroUS;
  auto _counter = _o->counter;
  auto _format = _o->format;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _imageStrideInBytes = _o->imageStrideInBytes;
  auto _imageHeaderVersion = _o->imageHeaderVersion;
  auto _imageHeaderStatus = _o->imageHeaderStatus;
  auto _imageLeftPixels = _o->imageLeftPixels.empty() ? 0 : _fbb.CreateString(_o->imageLeftPixels);
  auto _imageLeftPixelsVersion = _o->imageLeftPixelsVersion;
  auto _imageLeftStatus = _o->imageLeftStatus;
  auto _imageRightPixels = _o->imageRightPixels.empty() ? 0 : _fbb.CreateString(_o->imageRightPixels);
  auto _imageRightPixelsVersion = _o->imageRightPixelsVersion;
  auto _imageRightStatus = _o->imageRightStatus;
  auto _regionsOfInterestLeft = _o->regionsOfInterestLeft.size() ? _fbb.CreateVector<flatbuffers::Offset<ftkRegionOfInterest>> (_o->regionsOfInterestLeft.size(), [](size_t i, _VectorArgs *__va) { return CreateftkRegionOfInterest(*__va->__fbb, __va->__o->regionsOfInterestLeft[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _regionsOfInterestLeftVersion = _o->regionsOfInterestLeftVersion;
  auto _regionsOfInterestLeftStatus = _o->regionsOfInterestLeftStatus;
  auto _regionsOfInterestRight = _o->regionsOfInterestRight.size() ? _fbb.CreateVector<flatbuffers::Offset<ftkRegionOfInterest>> (_o->regionsOfInterestRight.size(), [](size_t i, _VectorArgs *__va) { return CreateftkRegionOfInterest(*__va->__fbb, __va->__o->regionsOfInterestRight[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _regionsOfInterestRightVersion = _o->regionsOfInterestRightVersion;
  auto _regionsOfInterestRightStatus = _o->regionsOfInterestRightStatus;
  auto _threeDFiducials = _o->threeDFiducials.size() ? _fbb.CreateVector<flatbuffers::Offset<ftk3DFiducial>> (_o->threeDFiducials.size(), [](size_t i, _VectorArgs *__va) { return Createftk3DFiducial(*__va->__fbb, __va->__o->threeDFiducials[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _threeDFiducialsVersion = _o->threeDFiducialsVersion;
  auto _threeDFiducialsStatus = _o->threeDFiducialsStatus;
  auto _markers = _o->markers.size() ? _fbb.CreateVector<flatbuffers::Offset<ftkMarker>> (_o->markers.size(), [](size_t i, _VectorArgs *__va) { return CreateftkMarker(*__va->__fbb, __va->__o->markers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _markersVersion = _o->markersVersion;
  auto _markersStatus = _o->markersStatus;
  auto _deviceType = _o->deviceType;
  auto _ftkError = _o->ftkError;
  return grl::flatbuffer::CreateFusionTrackFrame(
      _fbb,
      _timestamp,
      _serialNumber,
      _hardwareTimestampUS,
      _desynchroUS,
      _counter,
      _format,
      _width,
      _height,
      _imageStrideInBytes,
      _imageHeaderVersion,
      _imageHeaderStatus,
      _imageLeftPixels,
      _imageLeftPixelsVersion,
      _imageLeftStatus,
      _imageRightPixels,
      _imageRightPixelsVersion,
      _imageRightStatus,
      _regionsOfInterestLeft,
      _regionsOfInterestLeftVersion,
      _regionsOfInterestLeftStatus,
      _regionsOfInterestRight,
      _regionsOfInterestRightVersion,
      _regionsOfInterestRightStatus,
      _threeDFiducials,
      _threeDFiducialsVersion,
      _threeDFiducialsStatus,
      _markers,
      _markersVersion,
      _markersStatus,
      _deviceType,
      _ftkError);
}

inline FusionTrackParametersT *FusionTrackParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FusionTrackParametersT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FusionTrackParameters::UnPackTo(FusionTrackParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = deviceClockID(); if (_e) _o->deviceClockID = _e->str(); };
  { auto _e = localClockID(); if (_e) _o->localClockID = _e->str(); };
  { auto _e = geometries(); if (_e) { _o->geometries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->geometries[_i] = std::unique_ptr<ftkGeometryT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = geometryFilenames(); if (_e) { _o->geometryFilenames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->geometryFilenames[_i] = _e->Get(_i)->str(); } } };
  { auto _e = geometryDir(); if (_e) _o->geometryDir = _e->str(); };
  { auto _e = TrackerDeviceIDs(); if (_e) { _o->TrackerDeviceIDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->TrackerDeviceIDs[_i] = _e->Get(_i); } } };
  { auto _e = markerIDs(); if (_e) { _o->markerIDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->markerIDs[_i] = _e->Get(_i); } } };
  { auto _e = markerNames(); if (_e) { _o->markerNames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->markerNames[_i] = _e->Get(_i)->str(); } } };
  { auto _e = m_deviceSerialNumbers(); if (_e) { _o->m_deviceSerialNumbers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_deviceSerialNumbers[_i] = _e->Get(_i); } } };
  { auto _e = m_device_types(); if (_e) { _o->m_device_types.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_device_types[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<FusionTrackParameters> FusionTrackParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFusionTrackParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FusionTrackParameters> CreateFusionTrackParameters(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FusionTrackParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _deviceClockID = _o->deviceClockID.empty() ? 0 : _fbb.CreateString(_o->deviceClockID);
  auto _localClockID = _o->localClockID.empty() ? 0 : _fbb.CreateString(_o->localClockID);
  auto _geometries = _o->geometries.size() ? _fbb.CreateVector<flatbuffers::Offset<ftkGeometry>> (_o->geometries.size(), [](size_t i, _VectorArgs *__va) { return CreateftkGeometry(*__va->__fbb, __va->__o->geometries[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _geometryFilenames = _o->geometryFilenames.size() ? _fbb.CreateVectorOfStrings(_o->geometryFilenames) : 0;
  auto _geometryDir = _o->geometryDir.empty() ? 0 : _fbb.CreateString(_o->geometryDir);
  auto _TrackerDeviceIDs = _o->TrackerDeviceIDs.size() ? _fbb.CreateVector(_o->TrackerDeviceIDs) : 0;
  auto _markerIDs = _o->markerIDs.size() ? _fbb.CreateVector(_o->markerIDs) : 0;
  auto _markerNames = _o->markerNames.size() ? _fbb.CreateVectorOfStrings(_o->markerNames) : 0;
  auto _m_deviceSerialNumbers = _o->m_deviceSerialNumbers.size() ? _fbb.CreateVector(_o->m_deviceSerialNumbers) : 0;
  auto _m_device_types = _o->m_device_types.size() ? _fbb.CreateVector(_o->m_device_types) : 0;
  return grl::flatbuffer::CreateFusionTrackParameters(
      _fbb,
      _name,
      _deviceClockID,
      _localClockID,
      _geometries,
      _geometryFilenames,
      _geometryDir,
      _TrackerDeviceIDs,
      _markerIDs,
      _markerNames,
      _m_deviceSerialNumbers,
      _m_device_types);
}

inline FusionTrackMessageT *FusionTrackMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FusionTrackMessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FusionTrackMessage::UnPackTo(FusionTrackMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = timestamp(); _o->timestamp = _e; };
  { auto _e = parameters(); if (_e) _o->parameters = std::unique_ptr<FusionTrackParametersT>(_e->UnPack(_resolver)); };
  { auto _e = timeEvent(); if (_e) _o->timeEvent = std::unique_ptr<TimeEventT>(_e->UnPack(_resolver)); };
  { auto _e = frame(); if (_e) _o->frame = std::unique_ptr<FusionTrackFrameT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<FusionTrackMessage> FusionTrackMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFusionTrackMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FusionTrackMessage> CreateFusionTrackMessage(flatbuffers::FlatBufferBuilder &_fbb, const FusionTrackMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FusionTrackMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp = _o->timestamp;
  auto _parameters = _o->parameters ? CreateFusionTrackParameters(_fbb, _o->parameters.get(), _rehasher) : 0;
  auto _timeEvent = _o->timeEvent ? CreateTimeEvent(_fbb, _o->timeEvent.get(), _rehasher) : 0;
  auto _frame = _o->frame ? CreateFusionTrackFrame(_fbb, _o->frame.get(), _rehasher) : 0;
  return grl::flatbuffer::CreateFusionTrackMessage(
      _fbb,
      _timestamp,
      _parameters,
      _timeEvent,
      _frame);
}

}  // namespace flatbuffer
}  // namespace grl

#endif  // FLATBUFFERS_GENERATED_FUSIONTRACK_GRL_FLATBUFFER_H_
