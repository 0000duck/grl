// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_KUKAIIWA_GRL_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_KUKAIIWA_GRL_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

#include "ArmControlState_generated.h"
#include "Euler_generated.h"
#include "Geometry_generated.h"
#include "JointState_generated.h"
#include "LinkObject_generated.h"
#include "Time_generated.h"

namespace grl {
namespace flatbuffer {

struct CartesianImpedenceControlMode;
struct CartesianImpedenceControlModeT;

struct JointImpedenceControlMode;
struct JointImpedenceControlModeT;

struct Disabled;
struct DisabledT;

struct FRI;
struct FRIT;

struct SmartServo;
struct SmartServoT;

struct ProcessData;
struct ProcessDataT;

struct KUKAiiwaArmConfiguration;
struct KUKAiiwaArmConfigurationT;

struct KUKAiiwaMonitorConfiguration;
struct KUKAiiwaMonitorConfigurationT;

struct KUKAiiwaMonitorState;
struct KUKAiiwaMonitorStateT;

struct FRITimeStamp;
struct FRITimeStampT;

struct FRIMessageLog;
struct FRIMessageLogT;

struct KUKAiiwaState;
struct KUKAiiwaStateT;

struct KUKAiiwaStates;
struct KUKAiiwaStatesT;

enum class KUKAiiwaInterface : int8_t {
  Disabled = 0,
  SmartServo = 1,
  DirectServo = 2,
  FRI = 3,
  MIN = Disabled,
  MAX = FRI
};

inline const KUKAiiwaInterface (&EnumValuesKUKAiiwaInterface())[4] {
  static const KUKAiiwaInterface values[] = {
    KUKAiiwaInterface::Disabled,
    KUKAiiwaInterface::SmartServo,
    KUKAiiwaInterface::DirectServo,
    KUKAiiwaInterface::FRI
  };
  return values;
}

inline const char * const *EnumNamesKUKAiiwaInterface() {
  static const char * const names[] = {
    "Disabled",
    "SmartServo",
    "DirectServo",
    "FRI",
    nullptr
  };
  return names;
}

inline const char *EnumNameKUKAiiwaInterface(KUKAiiwaInterface e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKUKAiiwaInterface()[index];
}

enum class ESessionState : int8_t {
  /// No session
  IDLE = 0  /// Monitoring mode, receive state but connection too inconsistent to command
,
  MONITORING_WAIT = 1  /// Monitoring mode
,
  MONITORING_READY = 2  /// About to command (Overlay created in Java interface)
,
  COMMANDING_WAIT = 3  /// Actively commanding the arm with FRI
,
  COMMANDING_ACTIVE = 4,
  MIN = IDLE,
  MAX = COMMANDING_ACTIVE
};

inline const ESessionState (&EnumValuesESessionState())[5] {
  static const ESessionState values[] = {
    ESessionState::IDLE,
    ESessionState::MONITORING_WAIT,
    ESessionState::MONITORING_READY,
    ESessionState::COMMANDING_WAIT,
    ESessionState::COMMANDING_ACTIVE
  };
  return values;
}

inline const char * const *EnumNamesESessionState() {
  static const char * const names[] = {
    "IDLE",
    "MONITORING_WAIT",
    "MONITORING_READY",
    "COMMANDING_WAIT",
    "COMMANDING_ACTIVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameESessionState(ESessionState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesESessionState()[index];
}

enum class EConnectionQuality : int8_t {
  POOR = 0,
  FAIR = 1,
  GOOD = 2,
  EXCELLENT = 3,
  MIN = POOR,
  MAX = EXCELLENT
};

inline const EConnectionQuality (&EnumValuesEConnectionQuality())[4] {
  static const EConnectionQuality values[] = {
    EConnectionQuality::POOR,
    EConnectionQuality::FAIR,
    EConnectionQuality::GOOD,
    EConnectionQuality::EXCELLENT
  };
  return values;
}

inline const char * const *EnumNamesEConnectionQuality() {
  static const char * const names[] = {
    "POOR",
    "FAIR",
    "GOOD",
    "EXCELLENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameEConnectionQuality(EConnectionQuality e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEConnectionQuality()[index];
}

enum class ESafetyState : int8_t {
  NORMAL_OPERATION = 0,
  SAFETY_STOP_LEVEL_0 = 1,
  SAFETY_STOP_LEVEL_1 = 2,
  SAFETY_STOP_LEVEL_2 = 3,
  MIN = NORMAL_OPERATION,
  MAX = SAFETY_STOP_LEVEL_2
};

inline const ESafetyState (&EnumValuesESafetyState())[4] {
  static const ESafetyState values[] = {
    ESafetyState::NORMAL_OPERATION,
    ESafetyState::SAFETY_STOP_LEVEL_0,
    ESafetyState::SAFETY_STOP_LEVEL_1,
    ESafetyState::SAFETY_STOP_LEVEL_2
  };
  return values;
}

inline const char * const *EnumNamesESafetyState() {
  static const char * const names[] = {
    "NORMAL_OPERATION",
    "SAFETY_STOP_LEVEL_0",
    "SAFETY_STOP_LEVEL_1",
    "SAFETY_STOP_LEVEL_2",
    nullptr
  };
  return names;
}

inline const char *EnumNameESafetyState(ESafetyState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesESafetyState()[index];
}

enum class EOperationMode : int8_t {
  TEST_MODE_1 = 0,
  TEST_MODE_2 = 1,
  AUTOMATIC_MODE = 2,
  MIN = TEST_MODE_1,
  MAX = AUTOMATIC_MODE
};

inline const EOperationMode (&EnumValuesEOperationMode())[3] {
  static const EOperationMode values[] = {
    EOperationMode::TEST_MODE_1,
    EOperationMode::TEST_MODE_2,
    EOperationMode::AUTOMATIC_MODE
  };
  return values;
}

inline const char * const *EnumNamesEOperationMode() {
  static const char * const names[] = {
    "TEST_MODE_1",
    "TEST_MODE_2",
    "AUTOMATIC_MODE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEOperationMode(EOperationMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEOperationMode()[index];
}

enum class EDriveState : int8_t {
  /// Driving mode currently unused
  OFF = 1  /// About to drive
,
  TRANSITIONING = 2  /// Actively commanding arm
,
  ACTIVE = 3,
  MIN = OFF,
  MAX = ACTIVE
};

inline const EDriveState (&EnumValuesEDriveState())[3] {
  static const EDriveState values[] = {
    EDriveState::OFF,
    EDriveState::TRANSITIONING,
    EDriveState::ACTIVE
  };
  return values;
}

inline const char * const *EnumNamesEDriveState() {
  static const char * const names[] = {
    "OFF",
    "TRANSITIONING",
    "ACTIVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEDriveState(EDriveState e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(EDriveState::OFF);
  return EnumNamesEDriveState()[index];
}

enum class EControlMode : int8_t {
  POSITION_CONTROL_MODE = 0,
  CART_IMP_CONTROL_MODE = 1,
  JOINT_IMP_CONTROL_MODE = 2,
  NO_CONTROL = 3,
  MIN = POSITION_CONTROL_MODE,
  MAX = NO_CONTROL
};

inline const EControlMode (&EnumValuesEControlMode())[4] {
  static const EControlMode values[] = {
    EControlMode::POSITION_CONTROL_MODE,
    EControlMode::CART_IMP_CONTROL_MODE,
    EControlMode::JOINT_IMP_CONTROL_MODE,
    EControlMode::NO_CONTROL
  };
  return values;
}

inline const char * const *EnumNamesEControlMode() {
  static const char * const names[] = {
    "POSITION_CONTROL_MODE",
    "CART_IMP_CONTROL_MODE",
    "JOINT_IMP_CONTROL_MODE",
    "NO_CONTROL",
    nullptr
  };
  return names;
}

inline const char *EnumNameEControlMode(EControlMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEControlMode()[index];
}

/// Type of command being sent to the arm (Dimensonal units)
enum class EClientCommandMode : int8_t {
  NO_COMMAND_MODE = 0,
  POSITION = 1,
  WRENCH = 2,
  TORQUE = 3,
  MIN = NO_COMMAND_MODE,
  MAX = TORQUE
};

inline const EClientCommandMode (&EnumValuesEClientCommandMode())[4] {
  static const EClientCommandMode values[] = {
    EClientCommandMode::NO_COMMAND_MODE,
    EClientCommandMode::POSITION,
    EClientCommandMode::WRENCH,
    EClientCommandMode::TORQUE
  };
  return values;
}

inline const char * const *EnumNamesEClientCommandMode() {
  static const char * const names[] = {
    "NO_COMMAND_MODE",
    "POSITION",
    "WRENCH",
    "TORQUE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEClientCommandMode(EClientCommandMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEClientCommandMode()[index];
}

enum class EOverlayType : int8_t {
  NO_OVERLAY = 0,
  JOINT = 1,
  CARTESIAN = 2,
  MIN = NO_OVERLAY,
  MAX = CARTESIAN
};

inline const EOverlayType (&EnumValuesEOverlayType())[3] {
  static const EOverlayType values[] = {
    EOverlayType::NO_OVERLAY,
    EOverlayType::JOINT,
    EOverlayType::CARTESIAN
  };
  return values;
}

inline const char * const *EnumNamesEOverlayType() {
  static const char * const names[] = {
    "NO_OVERLAY",
    "JOINT",
    "CARTESIAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameEOverlayType(EOverlayType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEOverlayType()[index];
}

struct CartesianImpedenceControlModeT : public flatbuffers::NativeTable {
  typedef CartesianImpedenceControlMode TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.CartesianImpedenceControlModeT";
  }
  std::unique_ptr<EulerPose> stiffness;
  std::unique_ptr<EulerPose> damping;
  double nullspaceStiffness;
  double nullspaceDamping;
  std::unique_ptr<EulerPose> maxPathDeviation;
  std::unique_ptr<EulerPose> maxCartesianVelocity;
  std::unique_ptr<EulerPose> maxControlForce;
  bool maxControlForceExceededStop;
  CartesianImpedenceControlModeT()
      : nullspaceStiffness(0.0),
        nullspaceDamping(0.0),
        maxControlForceExceededStop(false) {
  }
};

struct CartesianImpedenceControlMode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CartesianImpedenceControlModeT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.CartesianImpedenceControlMode";
  }
  enum {
    VT_STIFFNESS = 4,
    VT_DAMPING = 6,
    VT_NULLSPACESTIFFNESS = 8,
    VT_NULLSPACEDAMPING = 10,
    VT_MAXPATHDEVIATION = 12,
    VT_MAXCARTESIANVELOCITY = 14,
    VT_MAXCONTROLFORCE = 16,
    VT_MAXCONTROLFORCEEXCEEDEDSTOP = 18
  };
  /// actual stiffness to set rot:[nm/rad]
  const EulerPose *stiffness() const {
    return GetStruct<const EulerPose *>(VT_STIFFNESS);
  }
  /// actual damping to set
  const EulerPose *damping() const {
    return GetStruct<const EulerPose *>(VT_DAMPING);
  }
  /// [Nm/rad] must be => 0.0
  double nullspaceStiffness() const {
    return GetField<double>(VT_NULLSPACESTIFFNESS, 0.0);
  }
  /// must be between 0.3-1.0 suggested is 0.7
  double nullspaceDamping() const {
    return GetField<double>(VT_NULLSPACEDAMPING, 0.0);
  }
  /// maximum deviation from set goal in mm and radians
  const EulerPose *maxPathDeviation() const {
    return GetStruct<const EulerPose *>(VT_MAXPATHDEVIATION);
  }
  /// trans: [mm/s] rot: [rad/s]
  const EulerPose *maxCartesianVelocity() const {
    return GetStruct<const EulerPose *>(VT_MAXCARTESIANVELOCITY);
  }
  /// xyz: Newtons rpy:Nm (all >=0)
  const EulerPose *maxControlForce() const {
    return GetStruct<const EulerPose *>(VT_MAXCONTROLFORCE);
  }
  /// stop if max control force is exceeded
  bool maxControlForceExceededStop() const {
    return GetField<uint8_t>(VT_MAXCONTROLFORCEEXCEEDEDSTOP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EulerPose>(verifier, VT_STIFFNESS) &&
           VerifyField<EulerPose>(verifier, VT_DAMPING) &&
           VerifyField<double>(verifier, VT_NULLSPACESTIFFNESS) &&
           VerifyField<double>(verifier, VT_NULLSPACEDAMPING) &&
           VerifyField<EulerPose>(verifier, VT_MAXPATHDEVIATION) &&
           VerifyField<EulerPose>(verifier, VT_MAXCARTESIANVELOCITY) &&
           VerifyField<EulerPose>(verifier, VT_MAXCONTROLFORCE) &&
           VerifyField<uint8_t>(verifier, VT_MAXCONTROLFORCEEXCEEDEDSTOP) &&
           verifier.EndTable();
  }
  CartesianImpedenceControlModeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CartesianImpedenceControlModeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CartesianImpedenceControlMode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CartesianImpedenceControlModeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CartesianImpedenceControlModeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stiffness(const EulerPose *stiffness) {
    fbb_.AddStruct(CartesianImpedenceControlMode::VT_STIFFNESS, stiffness);
  }
  void add_damping(const EulerPose *damping) {
    fbb_.AddStruct(CartesianImpedenceControlMode::VT_DAMPING, damping);
  }
  void add_nullspaceStiffness(double nullspaceStiffness) {
    fbb_.AddElement<double>(CartesianImpedenceControlMode::VT_NULLSPACESTIFFNESS, nullspaceStiffness, 0.0);
  }
  void add_nullspaceDamping(double nullspaceDamping) {
    fbb_.AddElement<double>(CartesianImpedenceControlMode::VT_NULLSPACEDAMPING, nullspaceDamping, 0.0);
  }
  void add_maxPathDeviation(const EulerPose *maxPathDeviation) {
    fbb_.AddStruct(CartesianImpedenceControlMode::VT_MAXPATHDEVIATION, maxPathDeviation);
  }
  void add_maxCartesianVelocity(const EulerPose *maxCartesianVelocity) {
    fbb_.AddStruct(CartesianImpedenceControlMode::VT_MAXCARTESIANVELOCITY, maxCartesianVelocity);
  }
  void add_maxControlForce(const EulerPose *maxControlForce) {
    fbb_.AddStruct(CartesianImpedenceControlMode::VT_MAXCONTROLFORCE, maxControlForce);
  }
  void add_maxControlForceExceededStop(bool maxControlForceExceededStop) {
    fbb_.AddElement<uint8_t>(CartesianImpedenceControlMode::VT_MAXCONTROLFORCEEXCEEDEDSTOP, static_cast<uint8_t>(maxControlForceExceededStop), 0);
  }
  explicit CartesianImpedenceControlModeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CartesianImpedenceControlModeBuilder &operator=(const CartesianImpedenceControlModeBuilder &);
  flatbuffers::Offset<CartesianImpedenceControlMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CartesianImpedenceControlMode>(end);
    return o;
  }
};

inline flatbuffers::Offset<CartesianImpedenceControlMode> CreateCartesianImpedenceControlMode(
    flatbuffers::FlatBufferBuilder &_fbb,
    const EulerPose *stiffness = 0,
    const EulerPose *damping = 0,
    double nullspaceStiffness = 0.0,
    double nullspaceDamping = 0.0,
    const EulerPose *maxPathDeviation = 0,
    const EulerPose *maxCartesianVelocity = 0,
    const EulerPose *maxControlForce = 0,
    bool maxControlForceExceededStop = false) {
  CartesianImpedenceControlModeBuilder builder_(_fbb);
  builder_.add_nullspaceDamping(nullspaceDamping);
  builder_.add_nullspaceStiffness(nullspaceStiffness);
  builder_.add_maxControlForce(maxControlForce);
  builder_.add_maxCartesianVelocity(maxCartesianVelocity);
  builder_.add_maxPathDeviation(maxPathDeviation);
  builder_.add_damping(damping);
  builder_.add_stiffness(stiffness);
  builder_.add_maxControlForceExceededStop(maxControlForceExceededStop);
  return builder_.Finish();
}

flatbuffers::Offset<CartesianImpedenceControlMode> CreateCartesianImpedenceControlMode(flatbuffers::FlatBufferBuilder &_fbb, const CartesianImpedenceControlModeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JointImpedenceControlModeT : public flatbuffers::NativeTable {
  typedef JointImpedenceControlMode TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.JointImpedenceControlModeT";
  }
  std::vector<double> stiffness;
  std::vector<double> damping;
  JointImpedenceControlModeT() {
  }
};

struct JointImpedenceControlMode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JointImpedenceControlModeT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.JointImpedenceControlMode";
  }
  enum {
    VT_STIFFNESS = 4,
    VT_DAMPING = 6
  };
  const flatbuffers::Vector<double> *stiffness() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STIFFNESS);
  }
  const flatbuffers::Vector<double> *damping() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DAMPING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STIFFNESS) &&
           verifier.Verify(stiffness()) &&
           VerifyOffset(verifier, VT_DAMPING) &&
           verifier.Verify(damping()) &&
           verifier.EndTable();
  }
  JointImpedenceControlModeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JointImpedenceControlModeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JointImpedenceControlMode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointImpedenceControlModeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JointImpedenceControlModeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stiffness(flatbuffers::Offset<flatbuffers::Vector<double>> stiffness) {
    fbb_.AddOffset(JointImpedenceControlMode::VT_STIFFNESS, stiffness);
  }
  void add_damping(flatbuffers::Offset<flatbuffers::Vector<double>> damping) {
    fbb_.AddOffset(JointImpedenceControlMode::VT_DAMPING, damping);
  }
  explicit JointImpedenceControlModeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JointImpedenceControlModeBuilder &operator=(const JointImpedenceControlModeBuilder &);
  flatbuffers::Offset<JointImpedenceControlMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JointImpedenceControlMode>(end);
    return o;
  }
};

inline flatbuffers::Offset<JointImpedenceControlMode> CreateJointImpedenceControlMode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> stiffness = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> damping = 0) {
  JointImpedenceControlModeBuilder builder_(_fbb);
  builder_.add_damping(damping);
  builder_.add_stiffness(stiffness);
  return builder_.Finish();
}

inline flatbuffers::Offset<JointImpedenceControlMode> CreateJointImpedenceControlModeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *stiffness = nullptr,
    const std::vector<double> *damping = nullptr) {
  return grl::flatbuffer::CreateJointImpedenceControlMode(
      _fbb,
      stiffness ? _fbb.CreateVector<double>(*stiffness) : 0,
      damping ? _fbb.CreateVector<double>(*damping) : 0);
}

flatbuffers::Offset<JointImpedenceControlMode> CreateJointImpedenceControlMode(flatbuffers::FlatBufferBuilder &_fbb, const JointImpedenceControlModeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DisabledT : public flatbuffers::NativeTable {
  typedef Disabled TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.DisabledT";
  }
  DisabledT() {
  }
};

struct Disabled FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DisabledT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.Disabled";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DisabledT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DisabledT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Disabled> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DisabledT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DisabledBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DisabledBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisabledBuilder &operator=(const DisabledBuilder &);
  flatbuffers::Offset<Disabled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Disabled>(end);
    return o;
  }
};

inline flatbuffers::Offset<Disabled> CreateDisabled(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DisabledBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Disabled> CreateDisabled(flatbuffers::FlatBufferBuilder &_fbb, const DisabledT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FRIT : public flatbuffers::NativeTable {
  typedef FRI TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FRIT";
  }
  EOverlayType overlayType;
  int32_t sendPeriodMillisec;
  int32_t setReceiveMultiplier;
  bool updatePortOnRemote;
  int16_t portOnRemote;
  bool updatePortOnController;
  int16_t portOnController;
  FRIT()
      : overlayType(EOverlayType::JOINT),
        sendPeriodMillisec(4),
        setReceiveMultiplier(5),
        updatePortOnRemote(false),
        portOnRemote(0),
        updatePortOnController(false),
        portOnController(0) {
  }
};

struct FRI FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FRIT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FRI";
  }
  enum {
    VT_OVERLAYTYPE = 4,
    VT_SENDPERIODMILLISEC = 6,
    VT_SETRECEIVEMULTIPLIER = 8,
    VT_UPDATEPORTONREMOTE = 10,
    VT_PORTONREMOTE = 12,
    VT_UPDATEPORTONCONTROLLER = 14,
    VT_PORTONCONTROLLER = 16
  };
  EOverlayType overlayType() const {
    return static_cast<EOverlayType>(GetField<int8_t>(VT_OVERLAYTYPE, 1));
  }
  /// Set the value for the send period of the connection from the KUKA controller to the remote side in [ms].
  /// This means, the KUKA controller will send cyclic FRI messages every sendPeriod milliseconds to the remote side.
  ///
  ///
  /// Parameters:
  /// sendPeriod - the send period in milliseconds, 1 <= sendPeriod <= 100.
  /// Note: The recommended value for good performance should be between 1-5 milliseconds.
  int32_t sendPeriodMillisec() const {
    return GetField<int32_t>(VT_SENDPERIODMILLISEC, 4);
  }
  /// Set the receive multiplier of the cycle time from the remote side to the KUKA controller.
  /// This multiplier defines the value of the receivePeriod which is calculated:
  /// receivePeriod = receiveMultiplier * sendPeriod
  ///
  /// The KUKA controller will expect a FRI response message every receivePeriod milliseconds from the remote side.
  ///
  /// The receivePeriod has to be within the range of:
  /// 1 <= receivePeriod <= 100.
  int32_t setReceiveMultiplier() const {
    return GetField<int32_t>(VT_SETRECEIVEMULTIPLIER, 5);
  }
  bool updatePortOnRemote() const {
    return GetField<uint8_t>(VT_UPDATEPORTONREMOTE, 0) != 0;
  }
  /// Set the port ID of the socket at the controller side.
  /// Note: Do not change this port ID, unless your application requires different port IDs on both ends of the FRI channel.
  /// For changing the FRI port ID on both sides, it is sufficient to call setPortOnRemote(int).
  /// Values of controllerPortID:
  /// "-1" - The configuration of setPortOnRemote(int) is used. This is the default.
  /// recommended range of port IDs: 30200 <= controllerPortID < 30210
  int16_t portOnRemote() const {
    return GetField<int16_t>(VT_PORTONREMOTE, 0);
  }
  bool updatePortOnController() const {
    return GetField<uint8_t>(VT_UPDATEPORTONCONTROLLER, 0) != 0;
  }
  ///  Set the port ID of the FRI channel at the remote side.
  ///  By default, this port ID is used on both sides of the FRI channel, unless specified otherwise by setPortOnController(int).
  ///
  ///  Values of portID:
  ///
  ///  default port ID: 30200
  ///  recommended range of port IDs: 30200 <= portID < 30210
  ///  Since the FRI channel utilizes UDP as connection layer, make sure, that your network topology (firewall, network services) are chosen accordingly.
  ///
  ///  Parameters:
  ///  portID - the port ID > 0 (also known as UDP port number)
  int16_t portOnController() const {
    return GetField<int16_t>(VT_PORTONCONTROLLER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OVERLAYTYPE) &&
           VerifyField<int32_t>(verifier, VT_SENDPERIODMILLISEC) &&
           VerifyField<int32_t>(verifier, VT_SETRECEIVEMULTIPLIER) &&
           VerifyField<uint8_t>(verifier, VT_UPDATEPORTONREMOTE) &&
           VerifyField<int16_t>(verifier, VT_PORTONREMOTE) &&
           VerifyField<uint8_t>(verifier, VT_UPDATEPORTONCONTROLLER) &&
           VerifyField<int16_t>(verifier, VT_PORTONCONTROLLER) &&
           verifier.EndTable();
  }
  FRIT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FRIT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FRI> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FRIT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FRIBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_overlayType(EOverlayType overlayType) {
    fbb_.AddElement<int8_t>(FRI::VT_OVERLAYTYPE, static_cast<int8_t>(overlayType), 1);
  }
  void add_sendPeriodMillisec(int32_t sendPeriodMillisec) {
    fbb_.AddElement<int32_t>(FRI::VT_SENDPERIODMILLISEC, sendPeriodMillisec, 4);
  }
  void add_setReceiveMultiplier(int32_t setReceiveMultiplier) {
    fbb_.AddElement<int32_t>(FRI::VT_SETRECEIVEMULTIPLIER, setReceiveMultiplier, 5);
  }
  void add_updatePortOnRemote(bool updatePortOnRemote) {
    fbb_.AddElement<uint8_t>(FRI::VT_UPDATEPORTONREMOTE, static_cast<uint8_t>(updatePortOnRemote), 0);
  }
  void add_portOnRemote(int16_t portOnRemote) {
    fbb_.AddElement<int16_t>(FRI::VT_PORTONREMOTE, portOnRemote, 0);
  }
  void add_updatePortOnController(bool updatePortOnController) {
    fbb_.AddElement<uint8_t>(FRI::VT_UPDATEPORTONCONTROLLER, static_cast<uint8_t>(updatePortOnController), 0);
  }
  void add_portOnController(int16_t portOnController) {
    fbb_.AddElement<int16_t>(FRI::VT_PORTONCONTROLLER, portOnController, 0);
  }
  explicit FRIBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FRIBuilder &operator=(const FRIBuilder &);
  flatbuffers::Offset<FRI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FRI>(end);
    return o;
  }
};

inline flatbuffers::Offset<FRI> CreateFRI(
    flatbuffers::FlatBufferBuilder &_fbb,
    EOverlayType overlayType = EOverlayType::JOINT,
    int32_t sendPeriodMillisec = 4,
    int32_t setReceiveMultiplier = 5,
    bool updatePortOnRemote = false,
    int16_t portOnRemote = 0,
    bool updatePortOnController = false,
    int16_t portOnController = 0) {
  FRIBuilder builder_(_fbb);
  builder_.add_setReceiveMultiplier(setReceiveMultiplier);
  builder_.add_sendPeriodMillisec(sendPeriodMillisec);
  builder_.add_portOnController(portOnController);
  builder_.add_portOnRemote(portOnRemote);
  builder_.add_updatePortOnController(updatePortOnController);
  builder_.add_updatePortOnRemote(updatePortOnRemote);
  builder_.add_overlayType(overlayType);
  return builder_.Finish();
}

flatbuffers::Offset<FRI> CreateFRI(flatbuffers::FlatBufferBuilder &_fbb, const FRIT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SmartServoT : public flatbuffers::NativeTable {
  typedef SmartServo TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.SmartServoT";
  }
  std::vector<double> jointAccelerationRel;
  std::vector<double> jointVelocityRel;
  bool updateMinimumTrajectoryExecutionTime;
  double minimumTrajectoryExecutionTime;
  SmartServoT()
      : updateMinimumTrajectoryExecutionTime(false),
        minimumTrajectoryExecutionTime(0.0) {
  }
};

struct SmartServo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmartServoT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.SmartServo";
  }
  enum {
    VT_JOINTACCELERATIONREL = 4,
    VT_JOINTVELOCITYREL = 6,
    VT_UPDATEMINIMUMTRAJECTORYEXECUTIONTIME = 8,
    VT_MINIMUMTRAJECTORYEXECUTIONTIME = 10
  };
  /// normalized joint accelerations from 0 to 1 relative to system capabilities
  const flatbuffers::Vector<double> *jointAccelerationRel() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_JOINTACCELERATIONREL);
  }
  /// normalized joint velocity from 0 to 1 relative to system capabilities
  const flatbuffers::Vector<double> *jointVelocityRel() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_JOINTVELOCITYREL);
  }
  bool updateMinimumTrajectoryExecutionTime() const {
    return GetField<uint8_t>(VT_UPDATEMINIMUMTRAJECTORYEXECUTIONTIME, 0) != 0;
  }
  double minimumTrajectoryExecutionTime() const {
    return GetField<double>(VT_MINIMUMTRAJECTORYEXECUTIONTIME, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JOINTACCELERATIONREL) &&
           verifier.Verify(jointAccelerationRel()) &&
           VerifyOffset(verifier, VT_JOINTVELOCITYREL) &&
           verifier.Verify(jointVelocityRel()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATEMINIMUMTRAJECTORYEXECUTIONTIME) &&
           VerifyField<double>(verifier, VT_MINIMUMTRAJECTORYEXECUTIONTIME) &&
           verifier.EndTable();
  }
  SmartServoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SmartServoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SmartServo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmartServoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SmartServoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_jointAccelerationRel(flatbuffers::Offset<flatbuffers::Vector<double>> jointAccelerationRel) {
    fbb_.AddOffset(SmartServo::VT_JOINTACCELERATIONREL, jointAccelerationRel);
  }
  void add_jointVelocityRel(flatbuffers::Offset<flatbuffers::Vector<double>> jointVelocityRel) {
    fbb_.AddOffset(SmartServo::VT_JOINTVELOCITYREL, jointVelocityRel);
  }
  void add_updateMinimumTrajectoryExecutionTime(bool updateMinimumTrajectoryExecutionTime) {
    fbb_.AddElement<uint8_t>(SmartServo::VT_UPDATEMINIMUMTRAJECTORYEXECUTIONTIME, static_cast<uint8_t>(updateMinimumTrajectoryExecutionTime), 0);
  }
  void add_minimumTrajectoryExecutionTime(double minimumTrajectoryExecutionTime) {
    fbb_.AddElement<double>(SmartServo::VT_MINIMUMTRAJECTORYEXECUTIONTIME, minimumTrajectoryExecutionTime, 0.0);
  }
  explicit SmartServoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SmartServoBuilder &operator=(const SmartServoBuilder &);
  flatbuffers::Offset<SmartServo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmartServo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmartServo> CreateSmartServo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> jointAccelerationRel = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> jointVelocityRel = 0,
    bool updateMinimumTrajectoryExecutionTime = false,
    double minimumTrajectoryExecutionTime = 0.0) {
  SmartServoBuilder builder_(_fbb);
  builder_.add_minimumTrajectoryExecutionTime(minimumTrajectoryExecutionTime);
  builder_.add_jointVelocityRel(jointVelocityRel);
  builder_.add_jointAccelerationRel(jointAccelerationRel);
  builder_.add_updateMinimumTrajectoryExecutionTime(updateMinimumTrajectoryExecutionTime);
  return builder_.Finish();
}

inline flatbuffers::Offset<SmartServo> CreateSmartServoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *jointAccelerationRel = nullptr,
    const std::vector<double> *jointVelocityRel = nullptr,
    bool updateMinimumTrajectoryExecutionTime = false,
    double minimumTrajectoryExecutionTime = 0.0) {
  return grl::flatbuffer::CreateSmartServo(
      _fbb,
      jointAccelerationRel ? _fbb.CreateVector<double>(*jointAccelerationRel) : 0,
      jointVelocityRel ? _fbb.CreateVector<double>(*jointVelocityRel) : 0,
      updateMinimumTrajectoryExecutionTime,
      minimumTrajectoryExecutionTime);
}

flatbuffers::Offset<SmartServo> CreateSmartServo(flatbuffers::FlatBufferBuilder &_fbb, const SmartServoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProcessDataT : public flatbuffers::NativeTable {
  typedef ProcessData TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ProcessDataT";
  }
  std::string dataType;
  std::string defaultValue;
  std::string displayName;
  std::string id;
  std::string min;
  std::string max;
  std::string unit;
  std::string value;
  bool shouldRemove;
  bool shouldUpdate;
  ProcessDataT()
      : shouldRemove(false),
        shouldUpdate(false) {
  }
};

/// "ProcessData" is a field that appears
/// on your physical kuka tablet.
/// This message allows you to update these
/// fields on the tablet yourself.
struct ProcessData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProcessDataT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.ProcessData";
  }
  enum {
    VT_DATATYPE = 4,
    VT_DEFAULTVALUE = 6,
    VT_DISPLAYNAME = 8,
    VT_ID = 10,
    VT_MIN = 12,
    VT_MAX = 14,
    VT_UNIT = 16,
    VT_VALUE = 18,
    VT_SHOULDREMOVE = 20,
    VT_SHOULDUPDATE = 22
  };
  const flatbuffers::String *dataType() const {
    return GetPointer<const flatbuffers::String *>(VT_DATATYPE);
  }
  const flatbuffers::String *defaultValue() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULTVALUE);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *min() const {
    return GetPointer<const flatbuffers::String *>(VT_MIN);
  }
  const flatbuffers::String *max() const {
    return GetPointer<const flatbuffers::String *>(VT_MAX);
  }
  const flatbuffers::String *unit() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIT);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  /// should the data be removed completely?
  bool shouldRemove() const {
    return GetField<uint8_t>(VT_SHOULDREMOVE, 0) != 0;
  }
  /// should the data be updated to these values?
  bool shouldUpdate() const {
    return GetField<uint8_t>(VT_SHOULDUPDATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATATYPE) &&
           verifier.Verify(dataType()) &&
           VerifyOffset(verifier, VT_DEFAULTVALUE) &&
           verifier.Verify(defaultValue()) &&
           VerifyOffset(verifier, VT_DISPLAYNAME) &&
           verifier.Verify(displayName()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.Verify(min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.Verify(max()) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.Verify(unit()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           VerifyField<uint8_t>(verifier, VT_SHOULDREMOVE) &&
           VerifyField<uint8_t>(verifier, VT_SHOULDUPDATE) &&
           verifier.EndTable();
  }
  ProcessDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProcessDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProcessData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProcessDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(flatbuffers::Offset<flatbuffers::String> dataType) {
    fbb_.AddOffset(ProcessData::VT_DATATYPE, dataType);
  }
  void add_defaultValue(flatbuffers::Offset<flatbuffers::String> defaultValue) {
    fbb_.AddOffset(ProcessData::VT_DEFAULTVALUE, defaultValue);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(ProcessData::VT_DISPLAYNAME, displayName);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(ProcessData::VT_ID, id);
  }
  void add_min(flatbuffers::Offset<flatbuffers::String> min) {
    fbb_.AddOffset(ProcessData::VT_MIN, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::String> max) {
    fbb_.AddOffset(ProcessData::VT_MAX, max);
  }
  void add_unit(flatbuffers::Offset<flatbuffers::String> unit) {
    fbb_.AddOffset(ProcessData::VT_UNIT, unit);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(ProcessData::VT_VALUE, value);
  }
  void add_shouldRemove(bool shouldRemove) {
    fbb_.AddElement<uint8_t>(ProcessData::VT_SHOULDREMOVE, static_cast<uint8_t>(shouldRemove), 0);
  }
  void add_shouldUpdate(bool shouldUpdate) {
    fbb_.AddElement<uint8_t>(ProcessData::VT_SHOULDUPDATE, static_cast<uint8_t>(shouldUpdate), 0);
  }
  explicit ProcessDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessDataBuilder &operator=(const ProcessDataBuilder &);
  flatbuffers::Offset<ProcessData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessData> CreateProcessData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> dataType = 0,
    flatbuffers::Offset<flatbuffers::String> defaultValue = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> min = 0,
    flatbuffers::Offset<flatbuffers::String> max = 0,
    flatbuffers::Offset<flatbuffers::String> unit = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0,
    bool shouldRemove = false,
    bool shouldUpdate = false) {
  ProcessDataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_unit(unit);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_id(id);
  builder_.add_displayName(displayName);
  builder_.add_defaultValue(defaultValue);
  builder_.add_dataType(dataType);
  builder_.add_shouldUpdate(shouldUpdate);
  builder_.add_shouldRemove(shouldRemove);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProcessData> CreateProcessDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataType = nullptr,
    const char *defaultValue = nullptr,
    const char *displayName = nullptr,
    const char *id = nullptr,
    const char *min = nullptr,
    const char *max = nullptr,
    const char *unit = nullptr,
    const char *value = nullptr,
    bool shouldRemove = false,
    bool shouldUpdate = false) {
  return grl::flatbuffer::CreateProcessData(
      _fbb,
      dataType ? _fbb.CreateString(dataType) : 0,
      defaultValue ? _fbb.CreateString(defaultValue) : 0,
      displayName ? _fbb.CreateString(displayName) : 0,
      id ? _fbb.CreateString(id) : 0,
      min ? _fbb.CreateString(min) : 0,
      max ? _fbb.CreateString(max) : 0,
      unit ? _fbb.CreateString(unit) : 0,
      value ? _fbb.CreateString(value) : 0,
      shouldRemove,
      shouldUpdate);
}

flatbuffers::Offset<ProcessData> CreateProcessData(flatbuffers::FlatBufferBuilder &_fbb, const ProcessDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KUKAiiwaArmConfigurationT : public flatbuffers::NativeTable {
  typedef KUKAiiwaArmConfiguration TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaArmConfigurationT";
  }
  std::string name;
  KUKAiiwaInterface commandInterface;
  KUKAiiwaInterface monitorInterface;
  EClientCommandMode clientCommandMode;
  EOverlayType overlayType;
  EControlMode controlMode;
  std::unique_ptr<CartesianImpedenceControlModeT> setCartImpedance;
  std::unique_ptr<JointImpedenceControlModeT> setJointImpedance;
  std::unique_ptr<SmartServoT> smartServoConfig;
  std::unique_ptr<FRIT> FRIConfig;
  std::vector<std::unique_ptr<LinkObjectT>> tools;
  std::vector<std::unique_ptr<ProcessDataT>> processData;
  std::string currentMotionCenter;
  bool requestMonitorProcessData;
  KUKAiiwaArmConfigurationT()
      : commandInterface(KUKAiiwaInterface::Disabled),
        monitorInterface(KUKAiiwaInterface::Disabled),
        clientCommandMode(EClientCommandMode::NO_COMMAND_MODE),
        overlayType(EOverlayType::NO_OVERLAY),
        controlMode(EControlMode::POSITION_CONTROL_MODE),
        requestMonitorProcessData(false) {
  }
};

struct KUKAiiwaArmConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KUKAiiwaArmConfigurationT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaArmConfiguration";
  }
  enum {
    VT_NAME = 4,
    VT_COMMANDINTERFACE = 6,
    VT_MONITORINTERFACE = 8,
    VT_CLIENTCOMMANDMODE = 10,
    VT_OVERLAYTYPE = 12,
    VT_CONTROLMODE = 14,
    VT_SETCARTIMPEDANCE = 16,
    VT_SETJOINTIMPEDANCE = 18,
    VT_SMARTSERVOCONFIG = 20,
    VT_FRICONFIG = 22,
    VT_TOOLS = 24,
    VT_PROCESSDATA = 26,
    VT_CURRENTMOTIONCENTER = 28,
    VT_REQUESTMONITORPROCESSDATA = 30
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// how commands will be sent to robot
  KUKAiiwaInterface commandInterface() const {
    return static_cast<KUKAiiwaInterface>(GetField<int8_t>(VT_COMMANDINTERFACE, 0));
  }
  /// how robot state will be sent to driver
  KUKAiiwaInterface monitorInterface() const {
    return static_cast<KUKAiiwaInterface>(GetField<int8_t>(VT_MONITORINTERFACE, 0));
  }
  /// motion command mode: cartesian, wrench, torque commands
  EClientCommandMode clientCommandMode() const {
    return static_cast<EClientCommandMode>(GetField<int8_t>(VT_CLIENTCOMMANDMODE, 0));
  }
  /// The type of commands FRI will use: cartesian, joint
  EOverlayType overlayType() const {
    return static_cast<EOverlayType>(GetField<int8_t>(VT_OVERLAYTYPE, 0));
  }
  /// position, cartesian impedence, or joint impedence low level controller adjustments
  EControlMode controlMode() const {
    return static_cast<EControlMode>(GetField<int8_t>(VT_CONTROLMODE, 0));
  }
  const CartesianImpedenceControlMode *setCartImpedance() const {
    return GetPointer<const CartesianImpedenceControlMode *>(VT_SETCARTIMPEDANCE);
  }
  const JointImpedenceControlMode *setJointImpedance() const {
    return GetPointer<const JointImpedenceControlMode *>(VT_SETJOINTIMPEDANCE);
  }
  const SmartServo *smartServoConfig() const {
    return GetPointer<const SmartServo *>(VT_SMARTSERVOCONFIG);
  }
  const FRI *FRIConfig() const {
    return GetPointer<const FRI *>(VT_FRICONFIG);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LinkObject>> *tools() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LinkObject>> *>(VT_TOOLS);
  }
  /// set kuka tablet "processData" panel UI config strings
  const flatbuffers::Vector<flatbuffers::Offset<ProcessData>> *processData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProcessData>> *>(VT_PROCESSDATA);
  }
  const flatbuffers::String *currentMotionCenter() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENTMOTIONCENTER);
  }
  bool requestMonitorProcessData() const {
    return GetField<uint8_t>(VT_REQUESTMONITORPROCESSDATA, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int8_t>(verifier, VT_COMMANDINTERFACE) &&
           VerifyField<int8_t>(verifier, VT_MONITORINTERFACE) &&
           VerifyField<int8_t>(verifier, VT_CLIENTCOMMANDMODE) &&
           VerifyField<int8_t>(verifier, VT_OVERLAYTYPE) &&
           VerifyField<int8_t>(verifier, VT_CONTROLMODE) &&
           VerifyOffset(verifier, VT_SETCARTIMPEDANCE) &&
           verifier.VerifyTable(setCartImpedance()) &&
           VerifyOffset(verifier, VT_SETJOINTIMPEDANCE) &&
           verifier.VerifyTable(setJointImpedance()) &&
           VerifyOffset(verifier, VT_SMARTSERVOCONFIG) &&
           verifier.VerifyTable(smartServoConfig()) &&
           VerifyOffset(verifier, VT_FRICONFIG) &&
           verifier.VerifyTable(FRIConfig()) &&
           VerifyOffset(verifier, VT_TOOLS) &&
           verifier.Verify(tools()) &&
           verifier.VerifyVectorOfTables(tools()) &&
           VerifyOffset(verifier, VT_PROCESSDATA) &&
           verifier.Verify(processData()) &&
           verifier.VerifyVectorOfTables(processData()) &&
           VerifyOffset(verifier, VT_CURRENTMOTIONCENTER) &&
           verifier.Verify(currentMotionCenter()) &&
           VerifyField<uint8_t>(verifier, VT_REQUESTMONITORPROCESSDATA) &&
           verifier.EndTable();
  }
  KUKAiiwaArmConfigurationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KUKAiiwaArmConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KUKAiiwaArmConfiguration> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaArmConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KUKAiiwaArmConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_NAME, name);
  }
  void add_commandInterface(KUKAiiwaInterface commandInterface) {
    fbb_.AddElement<int8_t>(KUKAiiwaArmConfiguration::VT_COMMANDINTERFACE, static_cast<int8_t>(commandInterface), 0);
  }
  void add_monitorInterface(KUKAiiwaInterface monitorInterface) {
    fbb_.AddElement<int8_t>(KUKAiiwaArmConfiguration::VT_MONITORINTERFACE, static_cast<int8_t>(monitorInterface), 0);
  }
  void add_clientCommandMode(EClientCommandMode clientCommandMode) {
    fbb_.AddElement<int8_t>(KUKAiiwaArmConfiguration::VT_CLIENTCOMMANDMODE, static_cast<int8_t>(clientCommandMode), 0);
  }
  void add_overlayType(EOverlayType overlayType) {
    fbb_.AddElement<int8_t>(KUKAiiwaArmConfiguration::VT_OVERLAYTYPE, static_cast<int8_t>(overlayType), 0);
  }
  void add_controlMode(EControlMode controlMode) {
    fbb_.AddElement<int8_t>(KUKAiiwaArmConfiguration::VT_CONTROLMODE, static_cast<int8_t>(controlMode), 0);
  }
  void add_setCartImpedance(flatbuffers::Offset<CartesianImpedenceControlMode> setCartImpedance) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_SETCARTIMPEDANCE, setCartImpedance);
  }
  void add_setJointImpedance(flatbuffers::Offset<JointImpedenceControlMode> setJointImpedance) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_SETJOINTIMPEDANCE, setJointImpedance);
  }
  void add_smartServoConfig(flatbuffers::Offset<SmartServo> smartServoConfig) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_SMARTSERVOCONFIG, smartServoConfig);
  }
  void add_FRIConfig(flatbuffers::Offset<FRI> FRIConfig) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_FRICONFIG, FRIConfig);
  }
  void add_tools(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LinkObject>>> tools) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_TOOLS, tools);
  }
  void add_processData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProcessData>>> processData) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_PROCESSDATA, processData);
  }
  void add_currentMotionCenter(flatbuffers::Offset<flatbuffers::String> currentMotionCenter) {
    fbb_.AddOffset(KUKAiiwaArmConfiguration::VT_CURRENTMOTIONCENTER, currentMotionCenter);
  }
  void add_requestMonitorProcessData(bool requestMonitorProcessData) {
    fbb_.AddElement<uint8_t>(KUKAiiwaArmConfiguration::VT_REQUESTMONITORPROCESSDATA, static_cast<uint8_t>(requestMonitorProcessData), 0);
  }
  explicit KUKAiiwaArmConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KUKAiiwaArmConfigurationBuilder &operator=(const KUKAiiwaArmConfigurationBuilder &);
  flatbuffers::Offset<KUKAiiwaArmConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KUKAiiwaArmConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<KUKAiiwaArmConfiguration> CreateKUKAiiwaArmConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    KUKAiiwaInterface commandInterface = KUKAiiwaInterface::Disabled,
    KUKAiiwaInterface monitorInterface = KUKAiiwaInterface::Disabled,
    EClientCommandMode clientCommandMode = EClientCommandMode::NO_COMMAND_MODE,
    EOverlayType overlayType = EOverlayType::NO_OVERLAY,
    EControlMode controlMode = EControlMode::POSITION_CONTROL_MODE,
    flatbuffers::Offset<CartesianImpedenceControlMode> setCartImpedance = 0,
    flatbuffers::Offset<JointImpedenceControlMode> setJointImpedance = 0,
    flatbuffers::Offset<SmartServo> smartServoConfig = 0,
    flatbuffers::Offset<FRI> FRIConfig = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LinkObject>>> tools = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProcessData>>> processData = 0,
    flatbuffers::Offset<flatbuffers::String> currentMotionCenter = 0,
    bool requestMonitorProcessData = false) {
  KUKAiiwaArmConfigurationBuilder builder_(_fbb);
  builder_.add_currentMotionCenter(currentMotionCenter);
  builder_.add_processData(processData);
  builder_.add_tools(tools);
  builder_.add_FRIConfig(FRIConfig);
  builder_.add_smartServoConfig(smartServoConfig);
  builder_.add_setJointImpedance(setJointImpedance);
  builder_.add_setCartImpedance(setCartImpedance);
  builder_.add_name(name);
  builder_.add_requestMonitorProcessData(requestMonitorProcessData);
  builder_.add_controlMode(controlMode);
  builder_.add_overlayType(overlayType);
  builder_.add_clientCommandMode(clientCommandMode);
  builder_.add_monitorInterface(monitorInterface);
  builder_.add_commandInterface(commandInterface);
  return builder_.Finish();
}

inline flatbuffers::Offset<KUKAiiwaArmConfiguration> CreateKUKAiiwaArmConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    KUKAiiwaInterface commandInterface = KUKAiiwaInterface::Disabled,
    KUKAiiwaInterface monitorInterface = KUKAiiwaInterface::Disabled,
    EClientCommandMode clientCommandMode = EClientCommandMode::NO_COMMAND_MODE,
    EOverlayType overlayType = EOverlayType::NO_OVERLAY,
    EControlMode controlMode = EControlMode::POSITION_CONTROL_MODE,
    flatbuffers::Offset<CartesianImpedenceControlMode> setCartImpedance = 0,
    flatbuffers::Offset<JointImpedenceControlMode> setJointImpedance = 0,
    flatbuffers::Offset<SmartServo> smartServoConfig = 0,
    flatbuffers::Offset<FRI> FRIConfig = 0,
    const std::vector<flatbuffers::Offset<LinkObject>> *tools = nullptr,
    const std::vector<flatbuffers::Offset<ProcessData>> *processData = nullptr,
    const char *currentMotionCenter = nullptr,
    bool requestMonitorProcessData = false) {
  return grl::flatbuffer::CreateKUKAiiwaArmConfiguration(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      commandInterface,
      monitorInterface,
      clientCommandMode,
      overlayType,
      controlMode,
      setCartImpedance,
      setJointImpedance,
      smartServoConfig,
      FRIConfig,
      tools ? _fbb.CreateVector<flatbuffers::Offset<LinkObject>>(*tools) : 0,
      processData ? _fbb.CreateVector<flatbuffers::Offset<ProcessData>>(*processData) : 0,
      currentMotionCenter ? _fbb.CreateString(currentMotionCenter) : 0,
      requestMonitorProcessData);
}

flatbuffers::Offset<KUKAiiwaArmConfiguration> CreateKUKAiiwaArmConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaArmConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KUKAiiwaMonitorConfigurationT : public flatbuffers::NativeTable {
  typedef KUKAiiwaMonitorConfiguration TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaMonitorConfigurationT";
  }
  std::string hardwareVersion;
  std::vector<double> torqueSensorLimits;
  bool isReadyToMove;
  bool isMastered;
  std::vector<std::unique_ptr<ProcessDataT>> processData;
  KUKAiiwaMonitorConfigurationT()
      : isReadyToMove(false),
        isMastered(false) {
  }
};

struct KUKAiiwaMonitorConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KUKAiiwaMonitorConfigurationT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaMonitorConfiguration";
  }
  enum {
    VT_HARDWAREVERSION = 4,
    VT_TORQUESENSORLIMITS = 6,
    VT_ISREADYTOMOVE = 8,
    VT_ISMASTERED = 10,
    VT_PROCESSDATA = 12
  };
  const flatbuffers::String *hardwareVersion() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWAREVERSION);
  }
  const flatbuffers::Vector<double> *torqueSensorLimits() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_TORQUESENSORLIMITS);
  }
  bool isReadyToMove() const {
    return GetField<uint8_t>(VT_ISREADYTOMOVE, 0) != 0;
  }
  bool isMastered() const {
    return GetField<uint8_t>(VT_ISMASTERED, 0) != 0;
  }
  /// set kuka tablet "processData" panel UI config strings
  const flatbuffers::Vector<flatbuffers::Offset<ProcessData>> *processData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProcessData>> *>(VT_PROCESSDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HARDWAREVERSION) &&
           verifier.Verify(hardwareVersion()) &&
           VerifyOffset(verifier, VT_TORQUESENSORLIMITS) &&
           verifier.Verify(torqueSensorLimits()) &&
           VerifyField<uint8_t>(verifier, VT_ISREADYTOMOVE) &&
           VerifyField<uint8_t>(verifier, VT_ISMASTERED) &&
           VerifyOffset(verifier, VT_PROCESSDATA) &&
           verifier.Verify(processData()) &&
           verifier.VerifyVectorOfTables(processData()) &&
           verifier.EndTable();
  }
  KUKAiiwaMonitorConfigurationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KUKAiiwaMonitorConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KUKAiiwaMonitorConfiguration> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KUKAiiwaMonitorConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hardwareVersion(flatbuffers::Offset<flatbuffers::String> hardwareVersion) {
    fbb_.AddOffset(KUKAiiwaMonitorConfiguration::VT_HARDWAREVERSION, hardwareVersion);
  }
  void add_torqueSensorLimits(flatbuffers::Offset<flatbuffers::Vector<double>> torqueSensorLimits) {
    fbb_.AddOffset(KUKAiiwaMonitorConfiguration::VT_TORQUESENSORLIMITS, torqueSensorLimits);
  }
  void add_isReadyToMove(bool isReadyToMove) {
    fbb_.AddElement<uint8_t>(KUKAiiwaMonitorConfiguration::VT_ISREADYTOMOVE, static_cast<uint8_t>(isReadyToMove), 0);
  }
  void add_isMastered(bool isMastered) {
    fbb_.AddElement<uint8_t>(KUKAiiwaMonitorConfiguration::VT_ISMASTERED, static_cast<uint8_t>(isMastered), 0);
  }
  void add_processData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProcessData>>> processData) {
    fbb_.AddOffset(KUKAiiwaMonitorConfiguration::VT_PROCESSDATA, processData);
  }
  explicit KUKAiiwaMonitorConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KUKAiiwaMonitorConfigurationBuilder &operator=(const KUKAiiwaMonitorConfigurationBuilder &);
  flatbuffers::Offset<KUKAiiwaMonitorConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KUKAiiwaMonitorConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<KUKAiiwaMonitorConfiguration> CreateKUKAiiwaMonitorConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hardwareVersion = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> torqueSensorLimits = 0,
    bool isReadyToMove = false,
    bool isMastered = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProcessData>>> processData = 0) {
  KUKAiiwaMonitorConfigurationBuilder builder_(_fbb);
  builder_.add_processData(processData);
  builder_.add_torqueSensorLimits(torqueSensorLimits);
  builder_.add_hardwareVersion(hardwareVersion);
  builder_.add_isMastered(isMastered);
  builder_.add_isReadyToMove(isReadyToMove);
  return builder_.Finish();
}

inline flatbuffers::Offset<KUKAiiwaMonitorConfiguration> CreateKUKAiiwaMonitorConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hardwareVersion = nullptr,
    const std::vector<double> *torqueSensorLimits = nullptr,
    bool isReadyToMove = false,
    bool isMastered = false,
    const std::vector<flatbuffers::Offset<ProcessData>> *processData = nullptr) {
  return grl::flatbuffer::CreateKUKAiiwaMonitorConfiguration(
      _fbb,
      hardwareVersion ? _fbb.CreateString(hardwareVersion) : 0,
      torqueSensorLimits ? _fbb.CreateVector<double>(*torqueSensorLimits) : 0,
      isReadyToMove,
      isMastered,
      processData ? _fbb.CreateVector<flatbuffers::Offset<ProcessData>>(*processData) : 0);
}

flatbuffers::Offset<KUKAiiwaMonitorConfiguration> CreateKUKAiiwaMonitorConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KUKAiiwaMonitorStateT : public flatbuffers::NativeTable {
  typedef KUKAiiwaMonitorState TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaMonitorStateT";
  }
  std::unique_ptr<JointStateT> measuredState;
  std::unique_ptr<Pose> cartesianFlangePose;
  std::unique_ptr<JointStateT> jointStateReal;
  std::unique_ptr<JointStateT> jointStateInterpolated;
  std::unique_ptr<JointStateT> externalState;
  EOperationMode operationMode;
  ESessionState sessionState;
  std::unique_ptr<Wrench> CartesianWrench;
  KUKAiiwaMonitorStateT()
      : operationMode(EOperationMode::TEST_MODE_1),
        sessionState(ESessionState::IDLE) {
  }
};

struct KUKAiiwaMonitorState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KUKAiiwaMonitorStateT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaMonitorState";
  }
  enum {
    VT_MEASUREDSTATE = 4,
    VT_CARTESIANFLANGEPOSE = 6,
    VT_JOINTSTATEREAL = 8,
    VT_JOINTSTATEINTERPOLATED = 10,
    VT_EXTERNALSTATE = 12,
    VT_OPERATIONMODE = 14,
    VT_SESSIONSTATE = 16,
    VT_CARTESIANWRENCH = 18
  };
  const JointState *measuredState() const {
    return GetPointer<const JointState *>(VT_MEASUREDSTATE);
  }
  const Pose *cartesianFlangePose() const {
    return GetStruct<const Pose *>(VT_CARTESIANFLANGEPOSE);
  }
  const JointState *jointStateReal() const {
    return GetPointer<const JointState *>(VT_JOINTSTATEREAL);
  }
  const JointState *jointStateInterpolated() const {
    return GetPointer<const JointState *>(VT_JOINTSTATEINTERPOLATED);
  }
  /// The state of the arm as calculated by kuka after
  /// subtracting the known weights of the arm
  /// and any attachments configured to be present.
  ///
  /// Most likely only contains torque.
  /// KukaState::ExternalTorque goes here
  const JointState *externalState() const {
    return GetPointer<const JointState *>(VT_EXTERNALSTATE);
  }
  /// KUKA::FRI::EOperationMode
  EOperationMode operationMode() const {
    return static_cast<EOperationMode>(GetField<int8_t>(VT_OPERATIONMODE, 0));
  }
  ESessionState sessionState() const {
    return static_cast<ESessionState>(GetField<int8_t>(VT_SESSIONSTATE, 0));
  }
  const Wrench *CartesianWrench() const {
    return GetStruct<const Wrench *>(VT_CARTESIANWRENCH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEASUREDSTATE) &&
           verifier.VerifyTable(measuredState()) &&
           VerifyField<Pose>(verifier, VT_CARTESIANFLANGEPOSE) &&
           VerifyOffset(verifier, VT_JOINTSTATEREAL) &&
           verifier.VerifyTable(jointStateReal()) &&
           VerifyOffset(verifier, VT_JOINTSTATEINTERPOLATED) &&
           verifier.VerifyTable(jointStateInterpolated()) &&
           VerifyOffset(verifier, VT_EXTERNALSTATE) &&
           verifier.VerifyTable(externalState()) &&
           VerifyField<int8_t>(verifier, VT_OPERATIONMODE) &&
           VerifyField<int8_t>(verifier, VT_SESSIONSTATE) &&
           VerifyField<Wrench>(verifier, VT_CARTESIANWRENCH) &&
           verifier.EndTable();
  }
  KUKAiiwaMonitorStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KUKAiiwaMonitorStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KUKAiiwaMonitorState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KUKAiiwaMonitorStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_measuredState(flatbuffers::Offset<JointState> measuredState) {
    fbb_.AddOffset(KUKAiiwaMonitorState::VT_MEASUREDSTATE, measuredState);
  }
  void add_cartesianFlangePose(const Pose *cartesianFlangePose) {
    fbb_.AddStruct(KUKAiiwaMonitorState::VT_CARTESIANFLANGEPOSE, cartesianFlangePose);
  }
  void add_jointStateReal(flatbuffers::Offset<JointState> jointStateReal) {
    fbb_.AddOffset(KUKAiiwaMonitorState::VT_JOINTSTATEREAL, jointStateReal);
  }
  void add_jointStateInterpolated(flatbuffers::Offset<JointState> jointStateInterpolated) {
    fbb_.AddOffset(KUKAiiwaMonitorState::VT_JOINTSTATEINTERPOLATED, jointStateInterpolated);
  }
  void add_externalState(flatbuffers::Offset<JointState> externalState) {
    fbb_.AddOffset(KUKAiiwaMonitorState::VT_EXTERNALSTATE, externalState);
  }
  void add_operationMode(EOperationMode operationMode) {
    fbb_.AddElement<int8_t>(KUKAiiwaMonitorState::VT_OPERATIONMODE, static_cast<int8_t>(operationMode), 0);
  }
  void add_sessionState(ESessionState sessionState) {
    fbb_.AddElement<int8_t>(KUKAiiwaMonitorState::VT_SESSIONSTATE, static_cast<int8_t>(sessionState), 0);
  }
  void add_CartesianWrench(const Wrench *CartesianWrench) {
    fbb_.AddStruct(KUKAiiwaMonitorState::VT_CARTESIANWRENCH, CartesianWrench);
  }
  explicit KUKAiiwaMonitorStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KUKAiiwaMonitorStateBuilder &operator=(const KUKAiiwaMonitorStateBuilder &);
  flatbuffers::Offset<KUKAiiwaMonitorState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KUKAiiwaMonitorState>(end);
    return o;
  }
};

inline flatbuffers::Offset<KUKAiiwaMonitorState> CreateKUKAiiwaMonitorState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<JointState> measuredState = 0,
    const Pose *cartesianFlangePose = 0,
    flatbuffers::Offset<JointState> jointStateReal = 0,
    flatbuffers::Offset<JointState> jointStateInterpolated = 0,
    flatbuffers::Offset<JointState> externalState = 0,
    EOperationMode operationMode = EOperationMode::TEST_MODE_1,
    ESessionState sessionState = ESessionState::IDLE,
    const Wrench *CartesianWrench = 0) {
  KUKAiiwaMonitorStateBuilder builder_(_fbb);
  builder_.add_CartesianWrench(CartesianWrench);
  builder_.add_externalState(externalState);
  builder_.add_jointStateInterpolated(jointStateInterpolated);
  builder_.add_jointStateReal(jointStateReal);
  builder_.add_cartesianFlangePose(cartesianFlangePose);
  builder_.add_measuredState(measuredState);
  builder_.add_sessionState(sessionState);
  builder_.add_operationMode(operationMode);
  return builder_.Finish();
}

flatbuffers::Offset<KUKAiiwaMonitorState> CreateKUKAiiwaMonitorState(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FRITimeStampT : public flatbuffers::NativeTable {
  typedef FRITimeStamp TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FRITimeStampT";
  }
  int32_t sec;
  int32_t nanosec;
  FRITimeStampT()
      : sec(0),
        nanosec(0) {
  }
};

struct FRITimeStamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FRITimeStampT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FRITimeStamp";
  }
  enum {
    VT_SEC = 4,
    VT_NANOSEC = 6
  };
  int32_t sec() const {
    return GetField<int32_t>(VT_SEC, 0);
  }
  int32_t nanosec() const {
    return GetField<int32_t>(VT_NANOSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEC) &&
           VerifyField<int32_t>(verifier, VT_NANOSEC) &&
           verifier.EndTable();
  }
  FRITimeStampT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FRITimeStampT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FRITimeStamp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FRITimeStampT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FRITimeStampBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sec(int32_t sec) {
    fbb_.AddElement<int32_t>(FRITimeStamp::VT_SEC, sec, 0);
  }
  void add_nanosec(int32_t nanosec) {
    fbb_.AddElement<int32_t>(FRITimeStamp::VT_NANOSEC, nanosec, 0);
  }
  explicit FRITimeStampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FRITimeStampBuilder &operator=(const FRITimeStampBuilder &);
  flatbuffers::Offset<FRITimeStamp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FRITimeStamp>(end);
    return o;
  }
};

inline flatbuffers::Offset<FRITimeStamp> CreateFRITimeStamp(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sec = 0,
    int32_t nanosec = 0) {
  FRITimeStampBuilder builder_(_fbb);
  builder_.add_nanosec(nanosec);
  builder_.add_sec(sec);
  return builder_.Finish();
}

flatbuffers::Offset<FRITimeStamp> CreateFRITimeStamp(flatbuffers::FlatBufferBuilder &_fbb, const FRITimeStampT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FRIMessageLogT : public flatbuffers::NativeTable {
  typedef FRIMessageLog TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FRIMessageLogT";
  }
  ESessionState sessionState;
  EConnectionQuality connectionQuality;
  EControlMode controlMode;
  int32_t messageIdentifier;
  int32_t sequenceCounter;
  int32_t reflectedSequenceCounter;
  std::vector<double> measuredJointPosition;
  std::vector<double> measuredTorque;
  std::vector<double> commandedJointPosition;
  std::vector<double> commandedTorque;
  std::vector<double> externalTorque;
  std::vector<double> jointStateInterpolated;
  std::unique_ptr<TimeEventT> timeStamp;
  FRIMessageLogT()
      : sessionState(ESessionState::IDLE),
        connectionQuality(EConnectionQuality::POOR),
        controlMode(EControlMode::POSITION_CONTROL_MODE),
        messageIdentifier(0),
        sequenceCounter(0),
        reflectedSequenceCounter(0) {
  }
};

struct FRIMessageLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FRIMessageLogT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.FRIMessageLog";
  }
  enum {
    VT_SESSIONSTATE = 4,
    VT_CONNECTIONQUALITY = 6,
    VT_CONTROLMODE = 8,
    VT_MESSAGEIDENTIFIER = 10,
    VT_SEQUENCECOUNTER = 12,
    VT_REFLECTEDSEQUENCECOUNTER = 14,
    VT_MEASUREDJOINTPOSITION = 16,
    VT_MEASUREDTORQUE = 18,
    VT_COMMANDEDJOINTPOSITION = 20,
    VT_COMMANDEDTORQUE = 22,
    VT_EXTERNALTORQUE = 24,
    VT_JOINTSTATEINTERPOLATED = 26,
    VT_TIMESTAMP = 28
  };
  ESessionState sessionState() const {
    return static_cast<ESessionState>(GetField<int8_t>(VT_SESSIONSTATE, 0));
  }
  EConnectionQuality connectionQuality() const {
    return static_cast<EConnectionQuality>(GetField<int8_t>(VT_CONNECTIONQUALITY, 0));
  }
  EControlMode controlMode() const {
    return static_cast<EControlMode>(GetField<int8_t>(VT_CONTROLMODE, 0));
  }
  int32_t messageIdentifier() const {
    return GetField<int32_t>(VT_MESSAGEIDENTIFIER, 0);
  }
  int32_t sequenceCounter() const {
    return GetField<int32_t>(VT_SEQUENCECOUNTER, 0);
  }
  int32_t reflectedSequenceCounter() const {
    return GetField<int32_t>(VT_REFLECTEDSEQUENCECOUNTER, 0);
  }
  const flatbuffers::Vector<double> *measuredJointPosition() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MEASUREDJOINTPOSITION);
  }
  const flatbuffers::Vector<double> *measuredTorque() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MEASUREDTORQUE);
  }
  const flatbuffers::Vector<double> *commandedJointPosition() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COMMANDEDJOINTPOSITION);
  }
  const flatbuffers::Vector<double> *commandedTorque() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COMMANDEDTORQUE);
  }
  const flatbuffers::Vector<double> *externalTorque() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_EXTERNALTORQUE);
  }
  const flatbuffers::Vector<double> *jointStateInterpolated() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_JOINTSTATEINTERPOLATED);
  }
  const TimeEvent *timeStamp() const {
    return GetPointer<const TimeEvent *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SESSIONSTATE) &&
           VerifyField<int8_t>(verifier, VT_CONNECTIONQUALITY) &&
           VerifyField<int8_t>(verifier, VT_CONTROLMODE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEIDENTIFIER) &&
           VerifyField<int32_t>(verifier, VT_SEQUENCECOUNTER) &&
           VerifyField<int32_t>(verifier, VT_REFLECTEDSEQUENCECOUNTER) &&
           VerifyOffset(verifier, VT_MEASUREDJOINTPOSITION) &&
           verifier.Verify(measuredJointPosition()) &&
           VerifyOffset(verifier, VT_MEASUREDTORQUE) &&
           verifier.Verify(measuredTorque()) &&
           VerifyOffset(verifier, VT_COMMANDEDJOINTPOSITION) &&
           verifier.Verify(commandedJointPosition()) &&
           VerifyOffset(verifier, VT_COMMANDEDTORQUE) &&
           verifier.Verify(commandedTorque()) &&
           VerifyOffset(verifier, VT_EXTERNALTORQUE) &&
           verifier.Verify(externalTorque()) &&
           VerifyOffset(verifier, VT_JOINTSTATEINTERPOLATED) &&
           verifier.Verify(jointStateInterpolated()) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timeStamp()) &&
           verifier.EndTable();
  }
  FRIMessageLogT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FRIMessageLogT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FRIMessageLog> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FRIMessageLogT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FRIMessageLogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sessionState(ESessionState sessionState) {
    fbb_.AddElement<int8_t>(FRIMessageLog::VT_SESSIONSTATE, static_cast<int8_t>(sessionState), 0);
  }
  void add_connectionQuality(EConnectionQuality connectionQuality) {
    fbb_.AddElement<int8_t>(FRIMessageLog::VT_CONNECTIONQUALITY, static_cast<int8_t>(connectionQuality), 0);
  }
  void add_controlMode(EControlMode controlMode) {
    fbb_.AddElement<int8_t>(FRIMessageLog::VT_CONTROLMODE, static_cast<int8_t>(controlMode), 0);
  }
  void add_messageIdentifier(int32_t messageIdentifier) {
    fbb_.AddElement<int32_t>(FRIMessageLog::VT_MESSAGEIDENTIFIER, messageIdentifier, 0);
  }
  void add_sequenceCounter(int32_t sequenceCounter) {
    fbb_.AddElement<int32_t>(FRIMessageLog::VT_SEQUENCECOUNTER, sequenceCounter, 0);
  }
  void add_reflectedSequenceCounter(int32_t reflectedSequenceCounter) {
    fbb_.AddElement<int32_t>(FRIMessageLog::VT_REFLECTEDSEQUENCECOUNTER, reflectedSequenceCounter, 0);
  }
  void add_measuredJointPosition(flatbuffers::Offset<flatbuffers::Vector<double>> measuredJointPosition) {
    fbb_.AddOffset(FRIMessageLog::VT_MEASUREDJOINTPOSITION, measuredJointPosition);
  }
  void add_measuredTorque(flatbuffers::Offset<flatbuffers::Vector<double>> measuredTorque) {
    fbb_.AddOffset(FRIMessageLog::VT_MEASUREDTORQUE, measuredTorque);
  }
  void add_commandedJointPosition(flatbuffers::Offset<flatbuffers::Vector<double>> commandedJointPosition) {
    fbb_.AddOffset(FRIMessageLog::VT_COMMANDEDJOINTPOSITION, commandedJointPosition);
  }
  void add_commandedTorque(flatbuffers::Offset<flatbuffers::Vector<double>> commandedTorque) {
    fbb_.AddOffset(FRIMessageLog::VT_COMMANDEDTORQUE, commandedTorque);
  }
  void add_externalTorque(flatbuffers::Offset<flatbuffers::Vector<double>> externalTorque) {
    fbb_.AddOffset(FRIMessageLog::VT_EXTERNALTORQUE, externalTorque);
  }
  void add_jointStateInterpolated(flatbuffers::Offset<flatbuffers::Vector<double>> jointStateInterpolated) {
    fbb_.AddOffset(FRIMessageLog::VT_JOINTSTATEINTERPOLATED, jointStateInterpolated);
  }
  void add_timeStamp(flatbuffers::Offset<TimeEvent> timeStamp) {
    fbb_.AddOffset(FRIMessageLog::VT_TIMESTAMP, timeStamp);
  }
  explicit FRIMessageLogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FRIMessageLogBuilder &operator=(const FRIMessageLogBuilder &);
  flatbuffers::Offset<FRIMessageLog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FRIMessageLog>(end);
    return o;
  }
};

inline flatbuffers::Offset<FRIMessageLog> CreateFRIMessageLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    ESessionState sessionState = ESessionState::IDLE,
    EConnectionQuality connectionQuality = EConnectionQuality::POOR,
    EControlMode controlMode = EControlMode::POSITION_CONTROL_MODE,
    int32_t messageIdentifier = 0,
    int32_t sequenceCounter = 0,
    int32_t reflectedSequenceCounter = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> measuredJointPosition = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> measuredTorque = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> commandedJointPosition = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> commandedTorque = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> externalTorque = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> jointStateInterpolated = 0,
    flatbuffers::Offset<TimeEvent> timeStamp = 0) {
  FRIMessageLogBuilder builder_(_fbb);
  builder_.add_timeStamp(timeStamp);
  builder_.add_jointStateInterpolated(jointStateInterpolated);
  builder_.add_externalTorque(externalTorque);
  builder_.add_commandedTorque(commandedTorque);
  builder_.add_commandedJointPosition(commandedJointPosition);
  builder_.add_measuredTorque(measuredTorque);
  builder_.add_measuredJointPosition(measuredJointPosition);
  builder_.add_reflectedSequenceCounter(reflectedSequenceCounter);
  builder_.add_sequenceCounter(sequenceCounter);
  builder_.add_messageIdentifier(messageIdentifier);
  builder_.add_controlMode(controlMode);
  builder_.add_connectionQuality(connectionQuality);
  builder_.add_sessionState(sessionState);
  return builder_.Finish();
}

inline flatbuffers::Offset<FRIMessageLog> CreateFRIMessageLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ESessionState sessionState = ESessionState::IDLE,
    EConnectionQuality connectionQuality = EConnectionQuality::POOR,
    EControlMode controlMode = EControlMode::POSITION_CONTROL_MODE,
    int32_t messageIdentifier = 0,
    int32_t sequenceCounter = 0,
    int32_t reflectedSequenceCounter = 0,
    const std::vector<double> *measuredJointPosition = nullptr,
    const std::vector<double> *measuredTorque = nullptr,
    const std::vector<double> *commandedJointPosition = nullptr,
    const std::vector<double> *commandedTorque = nullptr,
    const std::vector<double> *externalTorque = nullptr,
    const std::vector<double> *jointStateInterpolated = nullptr,
    flatbuffers::Offset<TimeEvent> timeStamp = 0) {
  return grl::flatbuffer::CreateFRIMessageLog(
      _fbb,
      sessionState,
      connectionQuality,
      controlMode,
      messageIdentifier,
      sequenceCounter,
      reflectedSequenceCounter,
      measuredJointPosition ? _fbb.CreateVector<double>(*measuredJointPosition) : 0,
      measuredTorque ? _fbb.CreateVector<double>(*measuredTorque) : 0,
      commandedJointPosition ? _fbb.CreateVector<double>(*commandedJointPosition) : 0,
      commandedTorque ? _fbb.CreateVector<double>(*commandedTorque) : 0,
      externalTorque ? _fbb.CreateVector<double>(*externalTorque) : 0,
      jointStateInterpolated ? _fbb.CreateVector<double>(*jointStateInterpolated) : 0,
      timeStamp);
}

flatbuffers::Offset<FRIMessageLog> CreateFRIMessageLog(flatbuffers::FlatBufferBuilder &_fbb, const FRIMessageLogT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KUKAiiwaStateT : public flatbuffers::NativeTable {
  typedef KUKAiiwaState TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaStateT";
  }
  std::string name;
  std::string destination;
  std::string source;
  std::unique_ptr<TimeEventT> timeStamp;
  bool setArmControlState;
  std::unique_ptr<ArmControlStateT> armControlState;
  bool setArmConfiguration;
  std::unique_ptr<KUKAiiwaArmConfigurationT> armConfiguration;
  bool hasMonitorState;
  std::unique_ptr<KUKAiiwaMonitorStateT> monitorState;
  bool hasMonitorConfig;
  std::unique_ptr<KUKAiiwaMonitorConfigurationT> monitorConfig;
  std::unique_ptr<FRIMessageLogT> FRIMessage;
  KUKAiiwaStateT()
      : setArmControlState(false),
        setArmConfiguration(false),
        hasMonitorState(false),
        hasMonitorConfig(false) {
  }
};

struct KUKAiiwaState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KUKAiiwaStateT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaState";
  }
  enum {
    VT_NAME = 4,
    VT_DESTINATION = 6,
    VT_SOURCE = 8,
    VT_TIMESTAMP = 10,
    VT_SETARMCONTROLSTATE = 12,
    VT_ARMCONTROLSTATE = 14,
    VT_SETARMCONFIGURATION = 16,
    VT_ARMCONFIGURATION = 18,
    VT_HASMONITORSTATE = 20,
    VT_MONITORSTATE = 22,
    VT_HASMONITORCONFIG = 24,
    VT_MONITORCONFIG = 26,
    VT_FRIMESSAGE = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *destination() const {
    return GetPointer<const flatbuffers::String *>(VT_DESTINATION);
  }
  const flatbuffers::String *source() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE);
  }
  const TimeEvent *timeStamp() const {
    return GetPointer<const TimeEvent *>(VT_TIMESTAMP);
  }
  bool setArmControlState() const {
    return GetField<uint8_t>(VT_SETARMCONTROLSTATE, 0) != 0;
  }
  const ArmControlState *armControlState() const {
    return GetPointer<const ArmControlState *>(VT_ARMCONTROLSTATE);
  }
  bool setArmConfiguration() const {
    return GetField<uint8_t>(VT_SETARMCONFIGURATION, 0) != 0;
  }
  const KUKAiiwaArmConfiguration *armConfiguration() const {
    return GetPointer<const KUKAiiwaArmConfiguration *>(VT_ARMCONFIGURATION);
  }
  bool hasMonitorState() const {
    return GetField<uint8_t>(VT_HASMONITORSTATE, 0) != 0;
  }
  const KUKAiiwaMonitorState *monitorState() const {
    return GetPointer<const KUKAiiwaMonitorState *>(VT_MONITORSTATE);
  }
  bool hasMonitorConfig() const {
    return GetField<uint8_t>(VT_HASMONITORCONFIG, 0) != 0;
  }
  const KUKAiiwaMonitorConfiguration *monitorConfig() const {
    return GetPointer<const KUKAiiwaMonitorConfiguration *>(VT_MONITORCONFIG);
  }
  const FRIMessageLog *FRIMessage() const {
    return GetPointer<const FRIMessageLog *>(VT_FRIMESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DESTINATION) &&
           verifier.Verify(destination()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.Verify(source()) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timeStamp()) &&
           VerifyField<uint8_t>(verifier, VT_SETARMCONTROLSTATE) &&
           VerifyOffset(verifier, VT_ARMCONTROLSTATE) &&
           verifier.VerifyTable(armControlState()) &&
           VerifyField<uint8_t>(verifier, VT_SETARMCONFIGURATION) &&
           VerifyOffset(verifier, VT_ARMCONFIGURATION) &&
           verifier.VerifyTable(armConfiguration()) &&
           VerifyField<uint8_t>(verifier, VT_HASMONITORSTATE) &&
           VerifyOffset(verifier, VT_MONITORSTATE) &&
           verifier.VerifyTable(monitorState()) &&
           VerifyField<uint8_t>(verifier, VT_HASMONITORCONFIG) &&
           VerifyOffset(verifier, VT_MONITORCONFIG) &&
           verifier.VerifyTable(monitorConfig()) &&
           VerifyOffset(verifier, VT_FRIMESSAGE) &&
           verifier.VerifyTable(FRIMessage()) &&
           verifier.EndTable();
  }
  KUKAiiwaStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KUKAiiwaStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KUKAiiwaState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KUKAiiwaStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(KUKAiiwaState::VT_NAME, name);
  }
  void add_destination(flatbuffers::Offset<flatbuffers::String> destination) {
    fbb_.AddOffset(KUKAiiwaState::VT_DESTINATION, destination);
  }
  void add_source(flatbuffers::Offset<flatbuffers::String> source) {
    fbb_.AddOffset(KUKAiiwaState::VT_SOURCE, source);
  }
  void add_timeStamp(flatbuffers::Offset<TimeEvent> timeStamp) {
    fbb_.AddOffset(KUKAiiwaState::VT_TIMESTAMP, timeStamp);
  }
  void add_setArmControlState(bool setArmControlState) {
    fbb_.AddElement<uint8_t>(KUKAiiwaState::VT_SETARMCONTROLSTATE, static_cast<uint8_t>(setArmControlState), 0);
  }
  void add_armControlState(flatbuffers::Offset<ArmControlState> armControlState) {
    fbb_.AddOffset(KUKAiiwaState::VT_ARMCONTROLSTATE, armControlState);
  }
  void add_setArmConfiguration(bool setArmConfiguration) {
    fbb_.AddElement<uint8_t>(KUKAiiwaState::VT_SETARMCONFIGURATION, static_cast<uint8_t>(setArmConfiguration), 0);
  }
  void add_armConfiguration(flatbuffers::Offset<KUKAiiwaArmConfiguration> armConfiguration) {
    fbb_.AddOffset(KUKAiiwaState::VT_ARMCONFIGURATION, armConfiguration);
  }
  void add_hasMonitorState(bool hasMonitorState) {
    fbb_.AddElement<uint8_t>(KUKAiiwaState::VT_HASMONITORSTATE, static_cast<uint8_t>(hasMonitorState), 0);
  }
  void add_monitorState(flatbuffers::Offset<KUKAiiwaMonitorState> monitorState) {
    fbb_.AddOffset(KUKAiiwaState::VT_MONITORSTATE, monitorState);
  }
  void add_hasMonitorConfig(bool hasMonitorConfig) {
    fbb_.AddElement<uint8_t>(KUKAiiwaState::VT_HASMONITORCONFIG, static_cast<uint8_t>(hasMonitorConfig), 0);
  }
  void add_monitorConfig(flatbuffers::Offset<KUKAiiwaMonitorConfiguration> monitorConfig) {
    fbb_.AddOffset(KUKAiiwaState::VT_MONITORCONFIG, monitorConfig);
  }
  void add_FRIMessage(flatbuffers::Offset<FRIMessageLog> FRIMessage) {
    fbb_.AddOffset(KUKAiiwaState::VT_FRIMESSAGE, FRIMessage);
  }
  explicit KUKAiiwaStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KUKAiiwaStateBuilder &operator=(const KUKAiiwaStateBuilder &);
  flatbuffers::Offset<KUKAiiwaState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KUKAiiwaState>(end);
    return o;
  }
};

inline flatbuffers::Offset<KUKAiiwaState> CreateKUKAiiwaState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> destination = 0,
    flatbuffers::Offset<flatbuffers::String> source = 0,
    flatbuffers::Offset<TimeEvent> timeStamp = 0,
    bool setArmControlState = false,
    flatbuffers::Offset<ArmControlState> armControlState = 0,
    bool setArmConfiguration = false,
    flatbuffers::Offset<KUKAiiwaArmConfiguration> armConfiguration = 0,
    bool hasMonitorState = false,
    flatbuffers::Offset<KUKAiiwaMonitorState> monitorState = 0,
    bool hasMonitorConfig = false,
    flatbuffers::Offset<KUKAiiwaMonitorConfiguration> monitorConfig = 0,
    flatbuffers::Offset<FRIMessageLog> FRIMessage = 0) {
  KUKAiiwaStateBuilder builder_(_fbb);
  builder_.add_FRIMessage(FRIMessage);
  builder_.add_monitorConfig(monitorConfig);
  builder_.add_monitorState(monitorState);
  builder_.add_armConfiguration(armConfiguration);
  builder_.add_armControlState(armControlState);
  builder_.add_timeStamp(timeStamp);
  builder_.add_source(source);
  builder_.add_destination(destination);
  builder_.add_name(name);
  builder_.add_hasMonitorConfig(hasMonitorConfig);
  builder_.add_hasMonitorState(hasMonitorState);
  builder_.add_setArmConfiguration(setArmConfiguration);
  builder_.add_setArmControlState(setArmControlState);
  return builder_.Finish();
}

inline flatbuffers::Offset<KUKAiiwaState> CreateKUKAiiwaStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *destination = nullptr,
    const char *source = nullptr,
    flatbuffers::Offset<TimeEvent> timeStamp = 0,
    bool setArmControlState = false,
    flatbuffers::Offset<ArmControlState> armControlState = 0,
    bool setArmConfiguration = false,
    flatbuffers::Offset<KUKAiiwaArmConfiguration> armConfiguration = 0,
    bool hasMonitorState = false,
    flatbuffers::Offset<KUKAiiwaMonitorState> monitorState = 0,
    bool hasMonitorConfig = false,
    flatbuffers::Offset<KUKAiiwaMonitorConfiguration> monitorConfig = 0,
    flatbuffers::Offset<FRIMessageLog> FRIMessage = 0) {
  return grl::flatbuffer::CreateKUKAiiwaState(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      destination ? _fbb.CreateString(destination) : 0,
      source ? _fbb.CreateString(source) : 0,
      timeStamp,
      setArmControlState,
      armControlState,
      setArmConfiguration,
      armConfiguration,
      hasMonitorState,
      monitorState,
      hasMonitorConfig,
      monitorConfig,
      FRIMessage);
}

flatbuffers::Offset<KUKAiiwaState> CreateKUKAiiwaState(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KUKAiiwaStatesT : public flatbuffers::NativeTable {
  typedef KUKAiiwaStates TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaStatesT";
  }
  std::vector<std::unique_ptr<KUKAiiwaStateT>> states;
  KUKAiiwaStatesT() {
  }
};

struct KUKAiiwaStates FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KUKAiiwaStatesT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "grl.flatbuffer.KUKAiiwaStates";
  }
  enum {
    VT_STATES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<KUKAiiwaState>> *states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KUKAiiwaState>> *>(VT_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.Verify(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           verifier.EndTable();
  }
  KUKAiiwaStatesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KUKAiiwaStatesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KUKAiiwaStates> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStatesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KUKAiiwaStatesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KUKAiiwaState>>> states) {
    fbb_.AddOffset(KUKAiiwaStates::VT_STATES, states);
  }
  explicit KUKAiiwaStatesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KUKAiiwaStatesBuilder &operator=(const KUKAiiwaStatesBuilder &);
  flatbuffers::Offset<KUKAiiwaStates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KUKAiiwaStates>(end);
    return o;
  }
};

inline flatbuffers::Offset<KUKAiiwaStates> CreateKUKAiiwaStates(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KUKAiiwaState>>> states = 0) {
  KUKAiiwaStatesBuilder builder_(_fbb);
  builder_.add_states(states);
  return builder_.Finish();
}

inline flatbuffers::Offset<KUKAiiwaStates> CreateKUKAiiwaStatesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<KUKAiiwaState>> *states = nullptr) {
  return grl::flatbuffer::CreateKUKAiiwaStates(
      _fbb,
      states ? _fbb.CreateVector<flatbuffers::Offset<KUKAiiwaState>>(*states) : 0);
}

flatbuffers::Offset<KUKAiiwaStates> CreateKUKAiiwaStates(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStatesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CartesianImpedenceControlModeT *CartesianImpedenceControlMode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CartesianImpedenceControlModeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CartesianImpedenceControlMode::UnPackTo(CartesianImpedenceControlModeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stiffness(); if (_e) _o->stiffness = std::unique_ptr<EulerPose>(new EulerPose(*_e)); };
  { auto _e = damping(); if (_e) _o->damping = std::unique_ptr<EulerPose>(new EulerPose(*_e)); };
  { auto _e = nullspaceStiffness(); _o->nullspaceStiffness = _e; };
  { auto _e = nullspaceDamping(); _o->nullspaceDamping = _e; };
  { auto _e = maxPathDeviation(); if (_e) _o->maxPathDeviation = std::unique_ptr<EulerPose>(new EulerPose(*_e)); };
  { auto _e = maxCartesianVelocity(); if (_e) _o->maxCartesianVelocity = std::unique_ptr<EulerPose>(new EulerPose(*_e)); };
  { auto _e = maxControlForce(); if (_e) _o->maxControlForce = std::unique_ptr<EulerPose>(new EulerPose(*_e)); };
  { auto _e = maxControlForceExceededStop(); _o->maxControlForceExceededStop = _e; };
}

inline flatbuffers::Offset<CartesianImpedenceControlMode> CartesianImpedenceControlMode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CartesianImpedenceControlModeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCartesianImpedenceControlMode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CartesianImpedenceControlMode> CreateCartesianImpedenceControlMode(flatbuffers::FlatBufferBuilder &_fbb, const CartesianImpedenceControlModeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CartesianImpedenceControlModeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _stiffness = _o->stiffness ? _o->stiffness.get() : 0;
  auto _damping = _o->damping ? _o->damping.get() : 0;
  auto _nullspaceStiffness = _o->nullspaceStiffness;
  auto _nullspaceDamping = _o->nullspaceDamping;
  auto _maxPathDeviation = _o->maxPathDeviation ? _o->maxPathDeviation.get() : 0;
  auto _maxCartesianVelocity = _o->maxCartesianVelocity ? _o->maxCartesianVelocity.get() : 0;
  auto _maxControlForce = _o->maxControlForce ? _o->maxControlForce.get() : 0;
  auto _maxControlForceExceededStop = _o->maxControlForceExceededStop;
  return grl::flatbuffer::CreateCartesianImpedenceControlMode(
      _fbb,
      _stiffness,
      _damping,
      _nullspaceStiffness,
      _nullspaceDamping,
      _maxPathDeviation,
      _maxCartesianVelocity,
      _maxControlForce,
      _maxControlForceExceededStop);
}

inline JointImpedenceControlModeT *JointImpedenceControlMode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new JointImpedenceControlModeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void JointImpedenceControlMode::UnPackTo(JointImpedenceControlModeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stiffness(); if (_e) { _o->stiffness.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stiffness[_i] = _e->Get(_i); } } };
  { auto _e = damping(); if (_e) { _o->damping.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->damping[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<JointImpedenceControlMode> JointImpedenceControlMode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointImpedenceControlModeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJointImpedenceControlMode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JointImpedenceControlMode> CreateJointImpedenceControlMode(flatbuffers::FlatBufferBuilder &_fbb, const JointImpedenceControlModeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const JointImpedenceControlModeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _stiffness = _o->stiffness.size() ? _fbb.CreateVector(_o->stiffness) : 0;
  auto _damping = _o->damping.size() ? _fbb.CreateVector(_o->damping) : 0;
  return grl::flatbuffer::CreateJointImpedenceControlMode(
      _fbb,
      _stiffness,
      _damping);
}

inline DisabledT *Disabled::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DisabledT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Disabled::UnPackTo(DisabledT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Disabled> Disabled::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DisabledT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDisabled(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Disabled> CreateDisabled(flatbuffers::FlatBufferBuilder &_fbb, const DisabledT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DisabledT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return grl::flatbuffer::CreateDisabled(
      _fbb);
}

inline FRIT *FRI::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FRIT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FRI::UnPackTo(FRIT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = overlayType(); _o->overlayType = _e; };
  { auto _e = sendPeriodMillisec(); _o->sendPeriodMillisec = _e; };
  { auto _e = setReceiveMultiplier(); _o->setReceiveMultiplier = _e; };
  { auto _e = updatePortOnRemote(); _o->updatePortOnRemote = _e; };
  { auto _e = portOnRemote(); _o->portOnRemote = _e; };
  { auto _e = updatePortOnController(); _o->updatePortOnController = _e; };
  { auto _e = portOnController(); _o->portOnController = _e; };
}

inline flatbuffers::Offset<FRI> FRI::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FRIT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFRI(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FRI> CreateFRI(flatbuffers::FlatBufferBuilder &_fbb, const FRIT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FRIT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _overlayType = _o->overlayType;
  auto _sendPeriodMillisec = _o->sendPeriodMillisec;
  auto _setReceiveMultiplier = _o->setReceiveMultiplier;
  auto _updatePortOnRemote = _o->updatePortOnRemote;
  auto _portOnRemote = _o->portOnRemote;
  auto _updatePortOnController = _o->updatePortOnController;
  auto _portOnController = _o->portOnController;
  return grl::flatbuffer::CreateFRI(
      _fbb,
      _overlayType,
      _sendPeriodMillisec,
      _setReceiveMultiplier,
      _updatePortOnRemote,
      _portOnRemote,
      _updatePortOnController,
      _portOnController);
}

inline SmartServoT *SmartServo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SmartServoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SmartServo::UnPackTo(SmartServoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = jointAccelerationRel(); if (_e) { _o->jointAccelerationRel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->jointAccelerationRel[_i] = _e->Get(_i); } } };
  { auto _e = jointVelocityRel(); if (_e) { _o->jointVelocityRel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->jointVelocityRel[_i] = _e->Get(_i); } } };
  { auto _e = updateMinimumTrajectoryExecutionTime(); _o->updateMinimumTrajectoryExecutionTime = _e; };
  { auto _e = minimumTrajectoryExecutionTime(); _o->minimumTrajectoryExecutionTime = _e; };
}

inline flatbuffers::Offset<SmartServo> SmartServo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmartServoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSmartServo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SmartServo> CreateSmartServo(flatbuffers::FlatBufferBuilder &_fbb, const SmartServoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SmartServoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _jointAccelerationRel = _o->jointAccelerationRel.size() ? _fbb.CreateVector(_o->jointAccelerationRel) : 0;
  auto _jointVelocityRel = _o->jointVelocityRel.size() ? _fbb.CreateVector(_o->jointVelocityRel) : 0;
  auto _updateMinimumTrajectoryExecutionTime = _o->updateMinimumTrajectoryExecutionTime;
  auto _minimumTrajectoryExecutionTime = _o->minimumTrajectoryExecutionTime;
  return grl::flatbuffer::CreateSmartServo(
      _fbb,
      _jointAccelerationRel,
      _jointVelocityRel,
      _updateMinimumTrajectoryExecutionTime,
      _minimumTrajectoryExecutionTime);
}

inline ProcessDataT *ProcessData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProcessDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProcessData::UnPackTo(ProcessDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dataType(); if (_e) _o->dataType = _e->str(); };
  { auto _e = defaultValue(); if (_e) _o->defaultValue = _e->str(); };
  { auto _e = displayName(); if (_e) _o->displayName = _e->str(); };
  { auto _e = id(); if (_e) _o->id = _e->str(); };
  { auto _e = min(); if (_e) _o->min = _e->str(); };
  { auto _e = max(); if (_e) _o->max = _e->str(); };
  { auto _e = unit(); if (_e) _o->unit = _e->str(); };
  { auto _e = value(); if (_e) _o->value = _e->str(); };
  { auto _e = shouldRemove(); _o->shouldRemove = _e; };
  { auto _e = shouldUpdate(); _o->shouldUpdate = _e; };
}

inline flatbuffers::Offset<ProcessData> ProcessData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProcessData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProcessData> CreateProcessData(flatbuffers::FlatBufferBuilder &_fbb, const ProcessDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProcessDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dataType = _o->dataType.empty() ? 0 : _fbb.CreateString(_o->dataType);
  auto _defaultValue = _o->defaultValue.empty() ? 0 : _fbb.CreateString(_o->defaultValue);
  auto _displayName = _o->displayName.empty() ? 0 : _fbb.CreateString(_o->displayName);
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _min = _o->min.empty() ? 0 : _fbb.CreateString(_o->min);
  auto _max = _o->max.empty() ? 0 : _fbb.CreateString(_o->max);
  auto _unit = _o->unit.empty() ? 0 : _fbb.CreateString(_o->unit);
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  auto _shouldRemove = _o->shouldRemove;
  auto _shouldUpdate = _o->shouldUpdate;
  return grl::flatbuffer::CreateProcessData(
      _fbb,
      _dataType,
      _defaultValue,
      _displayName,
      _id,
      _min,
      _max,
      _unit,
      _value,
      _shouldRemove,
      _shouldUpdate);
}

inline KUKAiiwaArmConfigurationT *KUKAiiwaArmConfiguration::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KUKAiiwaArmConfigurationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KUKAiiwaArmConfiguration::UnPackTo(KUKAiiwaArmConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = commandInterface(); _o->commandInterface = _e; };
  { auto _e = monitorInterface(); _o->monitorInterface = _e; };
  { auto _e = clientCommandMode(); _o->clientCommandMode = _e; };
  { auto _e = overlayType(); _o->overlayType = _e; };
  { auto _e = controlMode(); _o->controlMode = _e; };
  { auto _e = setCartImpedance(); if (_e) _o->setCartImpedance = std::unique_ptr<CartesianImpedenceControlModeT>(_e->UnPack(_resolver)); };
  { auto _e = setJointImpedance(); if (_e) _o->setJointImpedance = std::unique_ptr<JointImpedenceControlModeT>(_e->UnPack(_resolver)); };
  { auto _e = smartServoConfig(); if (_e) _o->smartServoConfig = std::unique_ptr<SmartServoT>(_e->UnPack(_resolver)); };
  { auto _e = FRIConfig(); if (_e) _o->FRIConfig = std::unique_ptr<FRIT>(_e->UnPack(_resolver)); };
  { auto _e = tools(); if (_e) { _o->tools.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tools[_i] = std::unique_ptr<LinkObjectT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = processData(); if (_e) { _o->processData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->processData[_i] = std::unique_ptr<ProcessDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = currentMotionCenter(); if (_e) _o->currentMotionCenter = _e->str(); };
  { auto _e = requestMonitorProcessData(); _o->requestMonitorProcessData = _e; };
}

inline flatbuffers::Offset<KUKAiiwaArmConfiguration> KUKAiiwaArmConfiguration::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaArmConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKUKAiiwaArmConfiguration(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KUKAiiwaArmConfiguration> CreateKUKAiiwaArmConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaArmConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KUKAiiwaArmConfigurationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _commandInterface = _o->commandInterface;
  auto _monitorInterface = _o->monitorInterface;
  auto _clientCommandMode = _o->clientCommandMode;
  auto _overlayType = _o->overlayType;
  auto _controlMode = _o->controlMode;
  auto _setCartImpedance = _o->setCartImpedance ? CreateCartesianImpedenceControlMode(_fbb, _o->setCartImpedance.get(), _rehasher) : 0;
  auto _setJointImpedance = _o->setJointImpedance ? CreateJointImpedenceControlMode(_fbb, _o->setJointImpedance.get(), _rehasher) : 0;
  auto _smartServoConfig = _o->smartServoConfig ? CreateSmartServo(_fbb, _o->smartServoConfig.get(), _rehasher) : 0;
  auto _FRIConfig = _o->FRIConfig ? CreateFRI(_fbb, _o->FRIConfig.get(), _rehasher) : 0;
  auto _tools = _o->tools.size() ? _fbb.CreateVector<flatbuffers::Offset<LinkObject>> (_o->tools.size(), [](size_t i, _VectorArgs *__va) { return CreateLinkObject(*__va->__fbb, __va->__o->tools[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _processData = _o->processData.size() ? _fbb.CreateVector<flatbuffers::Offset<ProcessData>> (_o->processData.size(), [](size_t i, _VectorArgs *__va) { return CreateProcessData(*__va->__fbb, __va->__o->processData[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _currentMotionCenter = _o->currentMotionCenter.empty() ? 0 : _fbb.CreateString(_o->currentMotionCenter);
  auto _requestMonitorProcessData = _o->requestMonitorProcessData;
  return grl::flatbuffer::CreateKUKAiiwaArmConfiguration(
      _fbb,
      _name,
      _commandInterface,
      _monitorInterface,
      _clientCommandMode,
      _overlayType,
      _controlMode,
      _setCartImpedance,
      _setJointImpedance,
      _smartServoConfig,
      _FRIConfig,
      _tools,
      _processData,
      _currentMotionCenter,
      _requestMonitorProcessData);
}

inline KUKAiiwaMonitorConfigurationT *KUKAiiwaMonitorConfiguration::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KUKAiiwaMonitorConfigurationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KUKAiiwaMonitorConfiguration::UnPackTo(KUKAiiwaMonitorConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hardwareVersion(); if (_e) _o->hardwareVersion = _e->str(); };
  { auto _e = torqueSensorLimits(); if (_e) { _o->torqueSensorLimits.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->torqueSensorLimits[_i] = _e->Get(_i); } } };
  { auto _e = isReadyToMove(); _o->isReadyToMove = _e; };
  { auto _e = isMastered(); _o->isMastered = _e; };
  { auto _e = processData(); if (_e) { _o->processData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->processData[_i] = std::unique_ptr<ProcessDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<KUKAiiwaMonitorConfiguration> KUKAiiwaMonitorConfiguration::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKUKAiiwaMonitorConfiguration(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KUKAiiwaMonitorConfiguration> CreateKUKAiiwaMonitorConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KUKAiiwaMonitorConfigurationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hardwareVersion = _o->hardwareVersion.empty() ? 0 : _fbb.CreateString(_o->hardwareVersion);
  auto _torqueSensorLimits = _o->torqueSensorLimits.size() ? _fbb.CreateVector(_o->torqueSensorLimits) : 0;
  auto _isReadyToMove = _o->isReadyToMove;
  auto _isMastered = _o->isMastered;
  auto _processData = _o->processData.size() ? _fbb.CreateVector<flatbuffers::Offset<ProcessData>> (_o->processData.size(), [](size_t i, _VectorArgs *__va) { return CreateProcessData(*__va->__fbb, __va->__o->processData[i].get(), __va->__rehasher); }, &_va ) : 0;
  return grl::flatbuffer::CreateKUKAiiwaMonitorConfiguration(
      _fbb,
      _hardwareVersion,
      _torqueSensorLimits,
      _isReadyToMove,
      _isMastered,
      _processData);
}

inline KUKAiiwaMonitorStateT *KUKAiiwaMonitorState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KUKAiiwaMonitorStateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KUKAiiwaMonitorState::UnPackTo(KUKAiiwaMonitorStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = measuredState(); if (_e) _o->measuredState = std::unique_ptr<JointStateT>(_e->UnPack(_resolver)); };
  { auto _e = cartesianFlangePose(); if (_e) _o->cartesianFlangePose = std::unique_ptr<Pose>(new Pose(*_e)); };
  { auto _e = jointStateReal(); if (_e) _o->jointStateReal = std::unique_ptr<JointStateT>(_e->UnPack(_resolver)); };
  { auto _e = jointStateInterpolated(); if (_e) _o->jointStateInterpolated = std::unique_ptr<JointStateT>(_e->UnPack(_resolver)); };
  { auto _e = externalState(); if (_e) _o->externalState = std::unique_ptr<JointStateT>(_e->UnPack(_resolver)); };
  { auto _e = operationMode(); _o->operationMode = _e; };
  { auto _e = sessionState(); _o->sessionState = _e; };
  { auto _e = CartesianWrench(); if (_e) _o->CartesianWrench = std::unique_ptr<Wrench>(new Wrench(*_e)); };
}

inline flatbuffers::Offset<KUKAiiwaMonitorState> KUKAiiwaMonitorState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKUKAiiwaMonitorState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KUKAiiwaMonitorState> CreateKUKAiiwaMonitorState(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaMonitorStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KUKAiiwaMonitorStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _measuredState = _o->measuredState ? CreateJointState(_fbb, _o->measuredState.get(), _rehasher) : 0;
  auto _cartesianFlangePose = _o->cartesianFlangePose ? _o->cartesianFlangePose.get() : 0;
  auto _jointStateReal = _o->jointStateReal ? CreateJointState(_fbb, _o->jointStateReal.get(), _rehasher) : 0;
  auto _jointStateInterpolated = _o->jointStateInterpolated ? CreateJointState(_fbb, _o->jointStateInterpolated.get(), _rehasher) : 0;
  auto _externalState = _o->externalState ? CreateJointState(_fbb, _o->externalState.get(), _rehasher) : 0;
  auto _operationMode = _o->operationMode;
  auto _sessionState = _o->sessionState;
  auto _CartesianWrench = _o->CartesianWrench ? _o->CartesianWrench.get() : 0;
  return grl::flatbuffer::CreateKUKAiiwaMonitorState(
      _fbb,
      _measuredState,
      _cartesianFlangePose,
      _jointStateReal,
      _jointStateInterpolated,
      _externalState,
      _operationMode,
      _sessionState,
      _CartesianWrench);
}

inline FRITimeStampT *FRITimeStamp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FRITimeStampT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FRITimeStamp::UnPackTo(FRITimeStampT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sec(); _o->sec = _e; };
  { auto _e = nanosec(); _o->nanosec = _e; };
}

inline flatbuffers::Offset<FRITimeStamp> FRITimeStamp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FRITimeStampT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFRITimeStamp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FRITimeStamp> CreateFRITimeStamp(flatbuffers::FlatBufferBuilder &_fbb, const FRITimeStampT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FRITimeStampT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sec = _o->sec;
  auto _nanosec = _o->nanosec;
  return grl::flatbuffer::CreateFRITimeStamp(
      _fbb,
      _sec,
      _nanosec);
}

inline FRIMessageLogT *FRIMessageLog::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FRIMessageLogT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FRIMessageLog::UnPackTo(FRIMessageLogT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionState(); _o->sessionState = _e; };
  { auto _e = connectionQuality(); _o->connectionQuality = _e; };
  { auto _e = controlMode(); _o->controlMode = _e; };
  { auto _e = messageIdentifier(); _o->messageIdentifier = _e; };
  { auto _e = sequenceCounter(); _o->sequenceCounter = _e; };
  { auto _e = reflectedSequenceCounter(); _o->reflectedSequenceCounter = _e; };
  { auto _e = measuredJointPosition(); if (_e) { _o->measuredJointPosition.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->measuredJointPosition[_i] = _e->Get(_i); } } };
  { auto _e = measuredTorque(); if (_e) { _o->measuredTorque.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->measuredTorque[_i] = _e->Get(_i); } } };
  { auto _e = commandedJointPosition(); if (_e) { _o->commandedJointPosition.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commandedJointPosition[_i] = _e->Get(_i); } } };
  { auto _e = commandedTorque(); if (_e) { _o->commandedTorque.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commandedTorque[_i] = _e->Get(_i); } } };
  { auto _e = externalTorque(); if (_e) { _o->externalTorque.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->externalTorque[_i] = _e->Get(_i); } } };
  { auto _e = jointStateInterpolated(); if (_e) { _o->jointStateInterpolated.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->jointStateInterpolated[_i] = _e->Get(_i); } } };
  { auto _e = timeStamp(); if (_e) _o->timeStamp = std::unique_ptr<TimeEventT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<FRIMessageLog> FRIMessageLog::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FRIMessageLogT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFRIMessageLog(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FRIMessageLog> CreateFRIMessageLog(flatbuffers::FlatBufferBuilder &_fbb, const FRIMessageLogT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FRIMessageLogT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionState = _o->sessionState;
  auto _connectionQuality = _o->connectionQuality;
  auto _controlMode = _o->controlMode;
  auto _messageIdentifier = _o->messageIdentifier;
  auto _sequenceCounter = _o->sequenceCounter;
  auto _reflectedSequenceCounter = _o->reflectedSequenceCounter;
  auto _measuredJointPosition = _o->measuredJointPosition.size() ? _fbb.CreateVector(_o->measuredJointPosition) : 0;
  auto _measuredTorque = _o->measuredTorque.size() ? _fbb.CreateVector(_o->measuredTorque) : 0;
  auto _commandedJointPosition = _o->commandedJointPosition.size() ? _fbb.CreateVector(_o->commandedJointPosition) : 0;
  auto _commandedTorque = _o->commandedTorque.size() ? _fbb.CreateVector(_o->commandedTorque) : 0;
  auto _externalTorque = _o->externalTorque.size() ? _fbb.CreateVector(_o->externalTorque) : 0;
  auto _jointStateInterpolated = _o->jointStateInterpolated.size() ? _fbb.CreateVector(_o->jointStateInterpolated) : 0;
  auto _timeStamp = _o->timeStamp ? CreateTimeEvent(_fbb, _o->timeStamp.get(), _rehasher) : 0;
  return grl::flatbuffer::CreateFRIMessageLog(
      _fbb,
      _sessionState,
      _connectionQuality,
      _controlMode,
      _messageIdentifier,
      _sequenceCounter,
      _reflectedSequenceCounter,
      _measuredJointPosition,
      _measuredTorque,
      _commandedJointPosition,
      _commandedTorque,
      _externalTorque,
      _jointStateInterpolated,
      _timeStamp);
}

inline KUKAiiwaStateT *KUKAiiwaState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KUKAiiwaStateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KUKAiiwaState::UnPackTo(KUKAiiwaStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = destination(); if (_e) _o->destination = _e->str(); };
  { auto _e = source(); if (_e) _o->source = _e->str(); };
  { auto _e = timeStamp(); if (_e) _o->timeStamp = std::unique_ptr<TimeEventT>(_e->UnPack(_resolver)); };
  { auto _e = setArmControlState(); _o->setArmControlState = _e; };
  { auto _e = armControlState(); if (_e) _o->armControlState = std::unique_ptr<ArmControlStateT>(_e->UnPack(_resolver)); };
  { auto _e = setArmConfiguration(); _o->setArmConfiguration = _e; };
  { auto _e = armConfiguration(); if (_e) _o->armConfiguration = std::unique_ptr<KUKAiiwaArmConfigurationT>(_e->UnPack(_resolver)); };
  { auto _e = hasMonitorState(); _o->hasMonitorState = _e; };
  { auto _e = monitorState(); if (_e) _o->monitorState = std::unique_ptr<KUKAiiwaMonitorStateT>(_e->UnPack(_resolver)); };
  { auto _e = hasMonitorConfig(); _o->hasMonitorConfig = _e; };
  { auto _e = monitorConfig(); if (_e) _o->monitorConfig = std::unique_ptr<KUKAiiwaMonitorConfigurationT>(_e->UnPack(_resolver)); };
  { auto _e = FRIMessage(); if (_e) _o->FRIMessage = std::unique_ptr<FRIMessageLogT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<KUKAiiwaState> KUKAiiwaState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKUKAiiwaState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KUKAiiwaState> CreateKUKAiiwaState(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KUKAiiwaStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _destination = _o->destination.empty() ? 0 : _fbb.CreateString(_o->destination);
  auto _source = _o->source.empty() ? 0 : _fbb.CreateString(_o->source);
  auto _timeStamp = _o->timeStamp ? CreateTimeEvent(_fbb, _o->timeStamp.get(), _rehasher) : 0;
  auto _setArmControlState = _o->setArmControlState;
  auto _armControlState = _o->armControlState ? CreateArmControlState(_fbb, _o->armControlState.get(), _rehasher) : 0;
  auto _setArmConfiguration = _o->setArmConfiguration;
  auto _armConfiguration = _o->armConfiguration ? CreateKUKAiiwaArmConfiguration(_fbb, _o->armConfiguration.get(), _rehasher) : 0;
  auto _hasMonitorState = _o->hasMonitorState;
  auto _monitorState = _o->monitorState ? CreateKUKAiiwaMonitorState(_fbb, _o->monitorState.get(), _rehasher) : 0;
  auto _hasMonitorConfig = _o->hasMonitorConfig;
  auto _monitorConfig = _o->monitorConfig ? CreateKUKAiiwaMonitorConfiguration(_fbb, _o->monitorConfig.get(), _rehasher) : 0;
  auto _FRIMessage = _o->FRIMessage ? CreateFRIMessageLog(_fbb, _o->FRIMessage.get(), _rehasher) : 0;
  return grl::flatbuffer::CreateKUKAiiwaState(
      _fbb,
      _name,
      _destination,
      _source,
      _timeStamp,
      _setArmControlState,
      _armControlState,
      _setArmConfiguration,
      _armConfiguration,
      _hasMonitorState,
      _monitorState,
      _hasMonitorConfig,
      _monitorConfig,
      _FRIMessage);
}

inline KUKAiiwaStatesT *KUKAiiwaStates::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KUKAiiwaStatesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KUKAiiwaStates::UnPackTo(KUKAiiwaStatesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = states(); if (_e) { _o->states.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->states[_i] = std::unique_ptr<KUKAiiwaStateT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<KUKAiiwaStates> KUKAiiwaStates::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStatesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKUKAiiwaStates(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KUKAiiwaStates> CreateKUKAiiwaStates(flatbuffers::FlatBufferBuilder &_fbb, const KUKAiiwaStatesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KUKAiiwaStatesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _states = _o->states.size() ? _fbb.CreateVector<flatbuffers::Offset<KUKAiiwaState>> (_o->states.size(), [](size_t i, _VectorArgs *__va) { return CreateKUKAiiwaState(*__va->__fbb, __va->__o->states[i].get(), __va->__rehasher); }, &_va ) : 0;
  return grl::flatbuffer::CreateKUKAiiwaStates(
      _fbb,
      _states);
}

inline const grl::flatbuffer::KUKAiiwaStates *GetKUKAiiwaStates(const void *buf) {
  return flatbuffers::GetRoot<grl::flatbuffer::KUKAiiwaStates>(buf);
}

inline const grl::flatbuffer::KUKAiiwaStates *GetSizePrefixedKUKAiiwaStates(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<grl::flatbuffer::KUKAiiwaStates>(buf);
}

inline const char *KUKAiiwaStatesIdentifier() {
  return "iiwa";
}

inline bool KUKAiiwaStatesBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, KUKAiiwaStatesIdentifier());
}

inline bool VerifyKUKAiiwaStatesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<grl::flatbuffer::KUKAiiwaStates>(KUKAiiwaStatesIdentifier());
}

inline bool VerifySizePrefixedKUKAiiwaStatesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<grl::flatbuffer::KUKAiiwaStates>(KUKAiiwaStatesIdentifier());
}

inline const char *KUKAiiwaStatesExtension() {
  return "iiwa";
}

inline void FinishKUKAiiwaStatesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<grl::flatbuffer::KUKAiiwaStates> root) {
  fbb.Finish(root, KUKAiiwaStatesIdentifier());
}

inline void FinishSizePrefixedKUKAiiwaStatesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<grl::flatbuffer::KUKAiiwaStates> root) {
  fbb.FinishSizePrefixed(root, KUKAiiwaStatesIdentifier());
}

inline std::unique_ptr<KUKAiiwaStatesT> UnPackKUKAiiwaStates(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<KUKAiiwaStatesT>(GetKUKAiiwaStates(buf)->UnPack(res));
}

}  // namespace flatbuffer
}  // namespace grl

#endif  // FLATBUFFERS_GENERATED_KUKAIIWA_GRL_FLATBUFFER_H_
